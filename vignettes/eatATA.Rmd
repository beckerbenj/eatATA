---
title: "eatATA"
author: "Benjamin Becker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{eatATA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Setup
The package can be installed from GitHub. Note that older R versions had issues with installations from online repositories like GitHub. `R` version `> 3.6.0` should work without any issues. 

```{r installation, eval = FALSE}
devtools::install_github("beckerbenj/eatATA")
```

To use `eatATA`, we need to install the `Gurobi` solver and its corresponding `R` package. An extensive vignette can be found [here](https://cran.r-project.org/web/packages/prioritizr/vignettes/gurobi_installation.html). 

```{r library, message = FALSE}
# loading all necessary packages
library(eatATA)
library(tidyr)
```


## Prepare item pool information
First we import the item pool information into `R`. For this purpose we recommend using the package `readxl`. As this package imports the data as a `tibble`, we transform it to a `data.frame`. `R` requires a rectangular data set (and often excel files store additional information outside of this format). The `skip` argument can be used to skip unnecessary rows in the `excel` file.

```{r import items, message = FALSE}
items_path <- system.file("extdata", "items.xlsx", package = "eatATA")

items <- as.data.frame(readxl::read_excel(path = items_path), stringsAsFactors = FALSE)


```

Next we clean the imported data and set up some fixed variables we want to use later.

```{r prep, message = FALSE}
# clean data set (categorical dummy variables must contain only 0 and 1)
for(ty in c(paste0("diff_", 1:5), "MC", "CMC", "short_answer", "open")){
  items[, ty] <- ifelse(is.na(items[, ty]), yes = 0, no = 1)
}

# set up fixed variables
n_items <- nrow(items)  # number of items
f <- 14                 # number of blocks
M <- n_items*f+1        # decision variable
```


## Set up constraints
`eatATA` offers a variety of constraints we can set. Usually we want the following constraints

* no item overlap between test blocks
* complete item pool depletion
* equal distribution of item formats across test blocks
* equal difficulty distribution across test blocks

```{r constraints}
# no item overlap,
ItemOverlap <- itemUsageConstraint(f, nItems = n_items, operator = "=") ## 0 means complete item pool usage

# item types
mcItems <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$MC, tolerance = 0.5)
cmcItems <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$CMC, tolerance = 0.5)
kaItems <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$short_answer, tolerance = 0.5)
offenItems <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$open, tolerance = 0.5)

# difficulty categories
Items1 <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$diff_1, tolerance = 0.5)
Items2 <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$diff_2, tolerance = 0.5)
Items3 <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$diff_3, tolerance = 0.5)
Items4 <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$diff_4, tolerance = 0.5)
Items5 <- singleParameterConstraint(nForms = f, nItems = n_items, itemValues = items$diff_5, tolerance = 0.5)

# number of items per test form
min_Nitems <- floor(n_items / f) - 3
noItems <- itemsPerFormConstraint(nForms = f, nItems = n_items, 
                                  operator = ">=", min_Nitems)

# item exclusions
exclusionTuples <- itemExclusionTuples(items, idCol = "Item_ID", exclusions = "exclusions")
excl_constraints <- itemExclusionConstraint(nForms = 14, exclusionTuples = exclusionTuples, itemIDs = items$Item_ID)

# optimize average time
av_time <- targetConstraint(f, nItems = n_items, itemValues = matrix(items$RT_in_min, nrow = 1), targetValues = 10,
                            thetaPoints = matrix(c(0)))


```


## Prepare constraints and run solver
No we cann call `Gurobis` `gurobi()` function, which will solve the optimization problem for us. If the problem is feasible, it will return... If it is infeasible, it will return...

```{r solver, eval = FALSE}
library(gurobi)
# Prepare constraints
gurobi_constr <- list(ItemOverlap = ItemOverlap, mcItems = mcItems, excl_constraints = excl_constraints,
                      av_time = av_time)
gurobi_rdy <- prepareConstraints(gurobi_constr, M = M, n_items = n_items, f = f)


# Optimization
solver_raw <- gurobi(gurobi_rdy, params = list(TimeLimit = 30))

```

## Inspect Solution

```{r inspect, eval = FALSE}
block_ind <- 0:13
names(block_ind) <- paste("Block", block_ind + 1, sep = "_")
block_df <- as.data.frame(lapply(block_ind, function(x) {
  ind <- x*80 + 1:80
  solver_raw$x[ind]
}))
## create block data.frame
new_items <- cbind(items[, c("Aufgabe", "Zeit Aufg.", "MC")], block_df)


## Print out solution for first 3 blocks
lapply(names(block_ind), function(nam) {
  df <- new_items[new_items[, nam] == 1, 1:3]
  list(df, c(time = sum(df[, 2]), Aufgaben = nrow(df)))
})[1:3]

```




## Save as Excel
Finally, it is often desirable to export the solution as an `Excel` file (`.xlsx`). This can, for example, be achieved via the `eatAnalysis` package, which has to be installed from Github.

```{r export solution to excel, eval = FALSE}
devtools::install_github("beckerbenj/eatAnalysis")
eatAnalysis::write_xlsx(new_items, filePath = "example_excel.xlsx",
                        row.names = FALSE)
```
