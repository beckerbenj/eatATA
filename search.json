[{"path":"https://beckerbenj.github.io/eatATA/articles/minimal_example.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Typical Use of `eatATA`: a Minimal Example","text":"eatATA package can installed CRAN.","code":"install.packages(\"eatATA\")"},{"path":"https://beckerbenj.github.io/eatATA/articles/minimal_example.html","id":"item-pool","dir":"Articles","previous_headings":"","what":"Item Pool","title":"Typical Use of `eatATA`: a Minimal Example","text":"First, eatATA loaded R session. vignette use small simulated item pool, items_mini. goal assemble single test form consisting ten items, average test time eight minutes maximum TIF medium ability. therefore calculate IIF medium ability append item pool using calculateIFF() function. Table 1 can see first five items item pool. Table 1. First 5 Items Item Pool","code":"# loading eatATA library(eatATA)  # item pool structure str(items_mini) #> 'data.frame':    30 obs. of  4 variables: #>  $ item      : int  1 2 3 4 5 6 7 8 9 10 ... #>  $ format    : chr  \"mc\" \"mc\" \"mc\" \"mc\" ... #>  $ time      : num  27.8 15.5 31 29.9 23.1 ... #>  $ difficulty: num  -1.881 0.843 1.119 0.729 -0.489 ...  # calculate and append IIF items_mini[, \"IIF_0\"] <- calculateIIF(B = items_mini$difficulty, theta = 0)"},{"path":"https://beckerbenj.github.io/eatATA/articles/minimal_example.html","id":"objective-function","dir":"Articles","previous_headings":"","what":"Objective Function","title":"Typical Use of `eatATA`: a Minimal Example","text":"Next, objective function defined: TIF maximized medium ability. , use maxObjective() function.","code":"testInfo <- maxObjective(nForms = 1, itemValues = items_mini$IIF,                           itemIDs = items_mini$item)"},{"path":"https://beckerbenj.github.io/eatATA/articles/minimal_example.html","id":"constraints","dir":"Articles","previous_headings":"","what":"Constraints","title":"Typical Use of `eatATA`: a Minimal Example","text":", fixed constraints defined additional constraint objects. Alternatively, determine appropriate test time based item pool using autoItemValuesMinMax() function.","code":"itemNumber <- itemsPerFormConstraint(nForms = 1, operator = \"=\",                                       targetValue = 10,                                       itemIDs = items_mini$item)  itemUsage <- itemUsageConstraint(nForms = 1, operator = \"<=\",                                   targetValue = 1,                                   itemIDs = items_mini$item)  testTime <- itemValuesDeviationConstraint(nForms = 1,                                  itemValues = items_mini$time,                                 targetValue = 8 * 60,                                  allowedDeviation = 5,                                 relative = FALSE,                                  itemIDs = items_mini$item) testTime2 <- autoItemValuesMinMaxConstraint(nForms = 1,                                  itemValues = items_mini$time,                                 testLength = 10,                                  allowedDeviation = 5,                                 relative = FALSE,                                  itemIDs = items_mini$item) #> The minimum and maximum values per test form are: min = 418.09 - max = 428.09"},{"path":"https://beckerbenj.github.io/eatATA/articles/minimal_example.html","id":"solver-usage","dir":"Articles","previous_headings":"","what":"Solver usage","title":"Typical Use of `eatATA`: a Minimal Example","text":"automatically assemble test form based constraints, call useSolver() function. function define solver used back end. default solver, recommend GLPK, automatically installed alongside package.","code":"solver_out <- useSolver(list(itemNumber, itemUsage, testTime, testInfo),                         solver = \"GLPK\") #> GLPK Simplex Optimizer 5.0 #> 34 rows, 31 columns, 151 non-zeros #>       0: obj =  -0.000000000e+00 inf =   4.850e+02 (2) #>      14: obj =  -0.000000000e+00 inf =   0.000e+00 (0) #> *    34: obj =   6.734471402e+00 inf =   4.441e-16 (0) #> OPTIMAL LP SOLUTION FOUND #> GLPK Integer Optimizer 5.0 #> 34 rows, 31 columns, 151 non-zeros #> 30 integer variables, all of which are binary #> Integer optimization begins... #> Long-step dual simplex will be used #> +    34: mip =     not found yet <=              +inf        (1; 0) #> +    44: >>>>>   6.579408205e+00 <=   6.732773863e+00   2.3% (9; 0) #> +    46: >>>>>   6.729573876e+00 <=   6.729573876e+00   0.0% (7; 5) #> +    46: mip =   6.729573876e+00 <=     tree is empty   0.0% (0; 19) #> INTEGER OPTIMAL SOLUTION FOUND"},{"path":"https://beckerbenj.github.io/eatATA/articles/minimal_example.html","id":"inspect-solution","dir":"Articles","previous_headings":"","what":"Inspect solution","title":"Typical Use of `eatATA`: a Minimal Example","text":"solution can inspected directly via inspectSolution() appended item pool via appendSolution(). Using inspectSolution() function additional row created calculates column sums numeric variables.","code":"inspectSolution(solver_out, items = items_mini, idCol = \"item\") #> $form_1 #>     item format      time  difficulty   theta=0 #> 8      8     mc  30.21856 -0.36707654 0.6564876 #> 14    14   open  62.99738  0.58136415 0.5712686 #> 15    15   open  56.59458 -0.12012428 0.7150196 #> 20    20   open  87.05063  0.10201223 0.7170949 #> 22    22  order  39.92415  0.15006395 0.7108712 #> 24    24  order  40.52289 -0.53606969 0.5910511 #> 25    25  order  52.15832  0.14083641 0.7122442 #> 26    26  order  38.29060  0.02381911 0.7222039 #> 28    28  order  43.77592  0.41298287 0.6403034 #> 29    29  order  25.55363  0.24091747 0.6930294 #> Sum  211   <NA> 477.08666  0.62872568 6.7295739 appendSolution(solver_out, items = items_mini, idCol = \"item\") #>    item format     time  difficulty    theta=0 form_1 #> 1     1     mc 27.78586 -1.88090278 0.10900318      0 #> 2     2     mc 15.45258  0.84295865 0.44945822      0 #> 3     3     mc 31.01590  1.11881538 0.32661056      0 #> 4     4     mc 29.87421  0.72867743 0.50339241      0 #> 5     5     mc 23.13401 -0.48870993 0.61088162      0 #> 6     6     mc 25.19305  0.47273874 0.61733915      0 #> 7     7     mc 25.66340 -1.18054268 0.30183441      0 #> 8     8     mc 30.21856 -0.36707654 0.65648760      1 #> 9     9     mc 26.61642 -0.56879434 0.57682871      0 #> 10   10     mc 15.35510  1.35397237 0.23900562      0 #> 11   11   open 65.85163 -0.75879786 0.48917461      0 #> 12   12   open 35.94400  2.49927381 0.04012039      0 #> 13   13   open 78.85030  1.33165799 0.24650909      0 #> 14   14   open 62.99738  0.58136415 0.57126860      1 #> 15   15   open 56.59458 -0.12012428 0.71501958      1 #> 16   16   open 45.12778 -1.28629686 0.26229560      0 #> 17   17   open 48.11908 -0.86124314 0.44088544      0 #> 18   18   open 76.32293  0.76977036 0.48398822      0 #> 19   19   open 76.20244 -1.39388826 0.22601541      0 #> 20   20   open 87.05063  0.10201223 0.71709486      1 #> 21   21  order 22.47400 -0.43147145 0.63341304      0 #> 22   22  order 39.92415  0.15006395 0.71087118      1 #> 23   23  order 57.71593 -0.82071059 0.45992776      0 #> 24   24  order 40.52289 -0.53606969 0.59105111      1 #> 25   25  order 52.15832  0.14083641 0.71224418      1 #> 26   26  order 38.29060  0.02381911 0.72220392      1 #> 27   27  order 45.97548  2.79595336 0.02450104      0 #> 28   28  order 43.77592  0.41298287 0.64030341      1 #> 29   29  order 25.55363  0.24091747 0.69302944      1 #> 30   30  order 19.50162 -0.51434114 0.60026891      0"},{"path":"https://beckerbenj.github.io/eatATA/articles/overview.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Overview of `eatATA` Functionality","text":"eatATA package can installed CRAN. default solver, recommend GLPK, automatically installed alongside package. lpSolve SYMPHONY also freely available open source solvers. want use Gurobi solver (powerful efficient solver currently supported eatATA), external software installation licensing required. means, need install Gurobi solver corresponding R package. detailed vignette installation process can found .","code":"install.packages(\"eatATA\") # loading eatATA library(eatATA)"},{"path":"https://beckerbenj.github.io/eatATA/articles/overview.html","id":"item-pool-preparation","dir":"Articles","previous_headings":"","what":"Item pool preparation","title":"Overview of `eatATA` Functionality","text":"eatATA provides functions prepare item pool test assembly: calculateIIF() calculatExpectedRT() dummiesToFactor() computeTargetValues() functions can used calculate item information function (calculateIIF()) expected response times (calculatExpectedRT()). dummiesToFactor() allows transformation variable coded multiple dummy variables single factor. computeTargetValues() allows calculation target values test form constraints, functionality also contained autoItemValuesMinMax() function. also number example item pools included package: * items_mini: small minimal example item pool * items_diao: item pool modeled first problem Diao & van der Linden (2011) * items_pilot: item pool calibration study * items_lsa: item pool block assembly large-scale assessment * items_vera: item pool similar Vergleichsarbeiten item pool","code":""},{"path":"https://beckerbenj.github.io/eatATA/articles/overview.html","id":"objective-function","dir":"Articles","previous_headings":"","what":"Objective function","title":"Overview of `eatATA` Functionality","text":"Constraints defining optimization goal automated test assembly: maxObjective() minObjective() maximinObjective() minimaxObjective() cappedMaximinObjective()","code":""},{"path":"https://beckerbenj.github.io/eatATA/articles/overview.html","id":"constraints","dir":"Articles","previous_headings":"","what":"Constraints","title":"Overview of `eatATA` Functionality","text":"list functions can used set constraints: Constraints controlling often item can used: depletePoolConstraint() itemUsageConstraint() Constraints controlling number items per test forms: itemUsageConstraint() itemsPerFormConstraint() Constraints controlling categorical properties items per test forms: itemCategoryConstraint() itemCategoryDeviationConstraint() itemCategoryMaxConstraint() itemCategoryMinConstraint() itemCategoryRangeConstraint() Constraints controlling metric properties items per test forms: autoItemValuesMinMaxConstraint() itemValuesConstraint() itemValuesDeviationConstraint() itemValuesMaxConstraint() itemValuesMinConstraint() itemValuesRangeConstraint() Constraints controlling metric properties items across test forms: acrossFormsConstraint() Constraints controlling item inclusions exclusions within test forms: itemExclusionConstraint() itemInclusionConstraint() Input inclusion exclusion function can prepared using: itemTuples() matrixExclusionTuples() stemInclusionTuples()","code":""},{"path":"https://beckerbenj.github.io/eatATA/articles/overview.html","id":"solver-function","dir":"Articles","previous_headings":"","what":"Solver function","title":"Overview of `eatATA` Functionality","text":"defining required constraints using functions , useSolver() can used call desired solver. Optionally, constraints can combined beforehand using combineConstraint() function.","code":""},{"path":"https://beckerbenj.github.io/eatATA/articles/overview.html","id":"using-the-solver-output","dir":"Articles","previous_headings":"","what":"Using the solver output","title":"Overview of `eatATA` Functionality","text":"useSolver() structures output consistently, independent solver used. output can processed inspectSolution() (inspect assembled booklets) appendSolution() (append assembly information existing item data.frame).","code":""},{"path":"https://beckerbenj.github.io/eatATA/articles/overview.html","id":"booklet-exclusions","dir":"Articles","previous_headings":"","what":"Booklet exclusions","title":"Overview of `eatATA` Functionality","text":"Test form assembly might performed two stage process, first assembling booklets items assembling test forms booklets. case, item exclusions might translate exclusions booklets level. Booklet exclusions can exist booklets one automated booklet assembly run booklets multiple automated booklet assembly runs. first case, analyzeBlockExclusion() can used inspect booklet exclusions. second case, analyzeComplexBlockExclusion() can used inspect booklet exclusions.","code":""},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"eatATA package can installed CRAN. First, eatATA loaded R session.","code":"install.packages(\"eatATA\") # loading eatATA library(eatATA)"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"item-pool","dir":"Articles","previous_headings":"","what":"Item pool","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"ATA without item pool. example use fictional example item pool 80 items. item pool information stored excel file included package. import item pool information R recommend using package readxl. package imports data tibble, code , item pool immediately transformed data.frame. Note R requires rectangular data set. Yet, often excel files store additional information rows “rectangular” item pool information. skip argument read_excel() function can used skip unnecessary rows excel file. (Note item pool can also directly accessed package via items; see ?items information.) Inspection item pool indicates items different properties: item format (MC, CMC, short_answer, open), difficulty (diff_1 - diff_5), average response times minutes (time). addition, similar items can booklet test form. information stored column exclusions, indicates items similar booklet item row..","code":"items_path <- system.file(\"extdata\", \"items.xlsx\", package = \"eatATA\")  items <- as.data.frame(readxl::read_excel(path = items_path), stringsAsFactors = FALSE) head(items) #>      item                exclusions time subitems MC CMC short_answer open #> 1 item_00          item_01, item_06  1.0        1 NA  NA            1   NA #> 2 item_01          item_00, item_06  1.5        1 NA  NA            1   NA #> 3 item_02 item_04, item_63, item_62  2.0        1 NA  NA           NA    1 #> 4 item_03                      <NA>  1.5        1 NA  NA            1   NA #> 5 item_04 item_02, item_63, item_62  1.5        1 NA  NA            1   NA #> 6 item_05                      <NA>  1.0        1 NA  NA            1   NA #>   diff_1 diff_2 diff_3 diff_4 diff_5 #> 1      1     NA     NA     NA     NA #> 2     NA      1     NA     NA     NA #> 3     NA     NA      1     NA     NA #> 4     NA     NA      1     NA     NA #> 5     NA      1     NA     NA     NA #> 6      1     NA     NA     NA     NA"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"prepare-item-information","dir":"Articles","previous_headings":"","what":"Prepare item information","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"defining constraints, item pool data correct format. instance, dummy variables (indicator variables) item pool use NA 0 indicate “category apply”. Therefore, dummy variables transformed two values (1 = “category applies”, 0 = “category apply”). Often set dummy variables can summarized single factor variable. automatically done function dummiesToFactor(). However, function can used categories mutually exclusive. instance, example item pool, items can contain sub-items different format difficulties. result, items contain two sub-items different formats. Therefore, example, dummiesToFactor() function throws error used. addition, column short_answer can NA value, consequently dummy variable. Therefore, () treat short_answer numerical value, (b) collapse MC open new factor MC_open_none, (dummies mutually exclusive), (c) turn CMC difficulty indicators factors. (See ?autoItemValuesMinMax ?computeTargetValues information different treatment factors numerical variables.)","code":"# clean data set (categorical dummy variables must contain only 0 and 1) items <- dummiesToFactor(items, dummies = c(\"MC\", \"CMC\", \"short_answer\", \"open\"), facVar = \"itemFormat\") #> Error in dummiesToFactor(items, dummies = c(\"MC\", \"CMC\", \"short_answer\", : All values in the 'dummies' columns have to be 0, 1 or NA. items <- dummiesToFactor(items, dummies = paste0(\"diff_\", 1:5), facVar = \"itemDiff\") #> Error in dummiesToFactor(items, dummies = paste0(\"diff_\", 1:5), facVar = \"itemDiff\"): All values in the 'dummies' columns have to be 0, 1 or NA. items[c(24, 33, 37, 47, 48, 54, 76), ] #>       item       exclusions time subitems MC CMC short_answer open diff_1 #> 24 item_23             <NA>  3.5        2  1   1           NA   NA     NA #> 33 item_32          item_36  1.5        2 NA  NA            2   NA      1 #> 37 item_36 item_27, item_32  1.5        2 NA  NA            2   NA      1 #> 47 item_46 item_54, item_44  2.5        2 NA  NA            2   NA     NA #> 48 item_47 item_45, item_37  2.0        2 NA  NA            2   NA     NA #> 54 item_53 item_43, item_59  2.5        2 NA  NA            2   NA     NA #> 76 item_75             <NA>  1.5        2 NA  NA            2   NA     NA #>    diff_2 diff_3 diff_4 diff_5 #> 24     NA      2     NA     NA #> 33     NA      1     NA     NA #> 37      1     NA     NA     NA #> 47      1      1     NA     NA #> 48     NA      1      1     NA #> 54      1      1     NA     NA #> 76     NA      1      1     NA # make new factor with three levels: \"MC\", \"open\" and \"else\" items <- dummiesToFactor(items, dummies = c(\"MC\", \"open\"), facVar = \"MC_open_none\") #> Warning in dummiesToFactor(items, dummies = c(\"MC\", \"open\"), facVar = \"MC_open_none\"): For these rows, there is no dummy variable equal to 1: 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 17, 20, 21, 25, 28, 29, 30, 32, 33, 34, 36, 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 50, 54, 55, 58, 60, 65, 67, 68, 69, 70, 72, 74, 76, 77, 79, 80 #> A '_none_ 'category is created for these rows. # clean data set (NA should be 0) for(ty in c(paste0(\"diff_\", 1:5), \"CMC\", \"short_answer\")){   items[, ty] <- ifelse(is.na(items[, ty]), yes = 0, no = items[, ty]) } # make factors of CMC dummi items$f_CMC <- factor(items$CMC, labels = paste(\"CMC\", c(\"no\", \"yes\"), sep = \"_\"))  # example item format table(items$short_answer) #>  #>  0  1  2  #> 34 38  8"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"ata-goal","dir":"Articles","previous_headings":"","what":"ATA goal","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"example, goal assemble 14 booklets 80 items item pool. items assigned one (one booklet), item overlap item pool completely depleted. precise, required constraints : item overlap test blocks complete item pool depletion equal distribution item formats across test blocks equal difficulty distribution across test blocks items can together booklet (item exclusions) similar possible response times across booklets Note booklets later manually assembled test forms. ease use, set two variables use frequently: number test forms booklets created (nForms) number items item pool (nItems). eatATA offers variety functions automatically compute constraints mentioned illustrated following.","code":"# set up fixed variables nItems <- nrow(items)  # number of items nForms <- 14           # number of blocks"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"objective-function","dir":"Articles","previous_headings":"","what":"Objective Function","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"First, setting optimization constraint. constraint clear yes constraint, attained perfectly. Instead, solver minimize distance actual booklet value booklets towards target value. example, specify 10 minutes target response time time booklets.","code":"# optimize average time av_time <- minimaxObjective(nForms, itemValues = items$time, targetValue = 10,                              itemIDs = items$item)"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"set-up-constraints","dir":"Articles","previous_headings":"","what":"Set up constraints","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"first two constraints (item overlap item pool depletion) can implemented single function: itemUsageConstraint(). achieve , operator argument set \"=\", meaning every item used exactly booklet assembly. Constraints respect categorical variables factors (like MC_open_none) numerical variables (like short_answer), can easily implemented using autoItemValuesMinMax() function. result function depends whether factor numerical variable used. , autoItemValuesMinMax() automatically determines minimum maximum frequency category factor. numerical variables, automatically determines target value. allowedDeviation argument specifies allowed range booklets regarding category numerical value. argument omitted, defaults “deviation allowed” numerical values, minimal possible deviation categorical variables factors. Hence, numeric values, specify allowedDeviation = 1. function prints calculated target value resulting allowed value range booklet level. implement item exclusion constraints, two function can used: itemExclusionTuples() itemExclusionConstraint(). item exclusions supplied single character string item, item identifiers separated \", \", transformed first. transformation can done using itemExclusionTuples() function, creates called tuples: pairs exclusive items. tuples can used directly itemExclusionConstraint() function. Another helpful function itemsPerFormConstraint() function, constrains number items per booklet. However, since required example, use constraints final ATA constraints.","code":"itemOverlap <- itemUsageConstraint(nForms, targetValue = 1,                                     operator = \"=\", itemIDs = items$item) # item formats mc_openItems <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$MC_open_none,                                       itemIDs = items$item) #> The minimum and maximum frequences per test form for each item category are #>        min max #> _none_   3   4 #> MC       1   2 #> open     0   1 cmcItems <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$f_CMC, itemIDs = items$item) #> The minimum and maximum frequences per test form for each item category are #>         min max #> CMC_no    5   6 #> CMC_yes   0   1 saItems <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$short_answer,                                  allowedDeviation = 1, itemIDs = items$item) #> The minimum and maximum values per test form are: min = 2.86 - max = 4.86  # difficulty categories Items1 <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$diff_1,                                 allowedDeviation = 1, itemIDs = items$item) #> The minimum and maximum values per test form are: min = 0 - max = 2 Items2 <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$diff_2,                                 allowedDeviation = 1, itemIDs = items$item) #> The minimum and maximum values per test form are: min = 0.57 - max = 2.57 Items3 <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$diff_3,                                 allowedDeviation = 1, itemIDs = items$item) #> The minimum and maximum values per test form are: min = 1.64 - max = 3.64 Items4 <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$diff_4,                                 allowedDeviation = 1, itemIDs = items$item) #> The minimum and maximum values per test form are: min = 0 - max = 1.86 Items5 <- autoItemValuesMinMaxConstraint(nForms = nForms, itemValues = items$diff_5,                                 allowedDeviation = 1, itemIDs = items$item) #> The minimum and maximum values per test form are: min = 0 - max = 1.29 # item exclusions variable items$exclusions[1:5] #> [1] \"item_01, item_06\"          \"item_00, item_06\"          #> [3] \"item_04, item_63, item_62\" NA                          #> [5] \"item_02, item_63, item_62\" # item exclusions exclusionTuples <- itemTuples(items, idCol = \"item\",                                         infoCol = \"exclusions\", sepPattern = \", \") excl_constraints <- itemExclusionConstraint(nForms = 14, itemTuples = exclusionTuples,                                              itemIDs = items$item) # number of items per test form min_Nitems <- floor(nItems / nForms) - 3 noItems <- itemsPerFormConstraint(nForms = nForms, operator = \">=\",                                    targetValue = min_Nitems, itemIDs = items$item)"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"run-solver","dir":"Articles","previous_headings":"","what":"Run solver","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"calling optimization algorithm specified constraints collected list. Now can call useSolver() function, restructures constraints internally solves optimization problem. Using solver argument specify GLPK solver (alternatives lpSolve, Symphony Gurobi). Using timeLimit argument set time limit 10. means limit solver stop searching optimal solution 10 seconds. Note computation times might depend solver selected. function provides output indicates whether optimal solution found. case, viable solution found function reached time limit finding optimal solution. feasible solution, one option relax constraints. , first diagnostic purposes can omit constraints completely, see constraints especially challenging. better grasp possibilities item pool, can add constraints back, example larger allowedDeviations.","code":"# Prepare constraints constr_list <- list(itemOverlap, mc_openItems, cmcItems, saItems,                        Items1, Items2, Items3, Items4, Items5,                        excl_constraints,                       av_time) # Optimization solver_raw <- useSolver(constr_list, nForms = nForms, nItems = nItems,                          itemIDs = items$item, solver = \"GLPK\", timeLimit = 10) #>  [1] \"GLPK Simplex Optimizer, v4.47\"                                            #>  [2] \"1046 rows, 1121 columns, 12824 non-zeros\"                                 #>  [3] \"      0: obj =  0.000000000e+000  infeas = 4.170e+002 (80)\"               #>  [4] \"*   411: obj =  5.879030940e-001  infeas = 7.963e-016 (0)\"                #>  [5] \"*   438: obj =  2.857142857e-001  infeas = 3.116e-029 (0)\"                #>  [6] \"OPTIMAL SOLUTION FOUND\"                                                   #>  [7] \"GLPK Integer Optimizer, v4.47\"                                            #>  [8] \"1046 rows, 1121 columns, 12824 non-zeros\"                                 #>  [9] \"1120 integer variables, all of which are binary\"                          #> [10] \"Integer optimization begins...\"                                           #> [11] \"+   438: mip =     not found yet >=              -inf        (1; 0)\"      #> [12] \"+  5675: >>>>>  1.500000000e+000 >=  2.857142857e-001  81.0% (303; 3)\"    #> [13] \"+  9322: >>>>>  1.000000000e+000 >=  2.857142857e-001  71.4% (540; 17)\"   #> [14] \"+ 17425: mip =  1.000000000e+000 >=  2.857142857e-001  71.4% (799; 433)\"  #> [15] \"+ 26418: mip =  1.000000000e+000 >=  2.857142857e-001  71.4% (1341; 491)\" #> [16] \"+ 34686: mip =  1.000000000e+000 >=  2.857142857e-001  71.4% (1850; 551)\" #> [17] \"+ 45535: mip =  1.000000000e+000 >=  2.857142857e-001  71.4% (2356; 644)\" #> [18] \"+ 54325: mip =  1.000000000e+000 >=  2.857142857e-001  71.4% (2695; 737)\" #> [19] \"TIME LIMIT EXCEEDED; SEARCH TERMINATED\" #> The solution is feasible, but may not be optimal"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"inspect-solution","dir":"Articles","previous_headings":"","what":"Inspect Solution","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"solution provided eatATA can inspected using inspectSolution() function. allows us inspect assembled item blocks first glance, including column sums. case want assemble created booklets test forms. Therefore, interested booklet exclusions can result item exclusions. analyzeBlockExclusion() function can used obtain tuples booklet exclusions.","code":"out_list <- inspectSolution(solver_raw, items = items, idCol = \"item\", colSums = TRUE,                             colNames = c(\"time\", \"subitems\",                                           \"MC\", \"CMC\", \"short_answer\", \"open\",                                          paste0(\"diff_\", 1:5)))  # first two booklets out_list[1:2] #> $form_1 #>     time subitems MC CMC short_answer open diff_1 diff_2 diff_3 diff_4 diff_5 #> 17   2.0        1 NA   0            1   NA      0      0      0      0      1 #> 19   2.0        1  1   0            0   NA      0      0      0      1      0 #> 27   1.5        1  1   0            0   NA      0      0      1      0      0 #> 41   1.0        1 NA   0            1   NA      0      0      1      0      0 #> 44   1.5        1 NA   0            1   NA      0      1      0      0      0 #> 55   1.0        1 NA   0            1   NA      0      1      0      0      0 #> Sum  9.0        6 NA   0            4   NA      0      2      2      1      1 #>  #> $form_2 #>     time subitems MC CMC short_answer open diff_1 diff_2 diff_3 diff_4 diff_5 #> 1    1.0        1 NA   0            1   NA      1      0      0      0      0 #> 10   1.0        1  1   0            0   NA      0      1      0      0      0 #> 20   1.5        1 NA   0            1   NA      0      0      1      0      0 #> 22   2.5        1  1   0            0   NA      0      0      1      0      0 #> 66   2.5        1 NA   0            0    1      0      1      0      0      0 #> 76   1.5        2 NA   0            2   NA      0      0      1      1      0 #> Sum 10.0        7 NA   0            4   NA      1      2      3      1      0 analyzeBlockExclusion(solverOut = solver_raw, item = items, idCol = \"item\",                        exclusionTuples = exclusionTuples) #>     Name 1  Name 2 #> 1  form_12  form_2 #> 2  form_11  form_2 #> 3  form_11 form_12 #> 4  form_13  form_5 #> 5  form_13  form_4 #> 6  form_13  form_6 #> 7   form_4  form_5 #> 8   form_5  form_6 #> 9  form_12  form_4 #> 10 form_10  form_7 #> 11 form_10 form_13 #> 12 form_10  form_2 #> 13  form_6  form_9 #> 14 form_13  form_3 #> 15 form_13  form_7 #> 16  form_2  form_7 #> 17 form_13  form_2 #> 18 form_11  form_8 #> 19  form_1 form_12 #> 20  form_1 form_14 #> 22 form_12  form_9 #> 23 form_10  form_6 #> 25  form_1 form_10 #> 26 form_13  form_8 #> 27 form_11  form_3 #> 28  form_3  form_4 #> 29  form_5  form_8 #> 32  form_5  form_7 #> 35  form_1  form_3 #> 37  form_1  form_9 #> 38 form_12  form_3 #> 39  form_1  form_6 #> 40 form_12 form_14 #> 41  form_3  form_8 #> 42 form_14  form_3 #> 44  form_4  form_6 #> 45 form_12  form_7"},{"path":"https://beckerbenj.github.io/eatATA/articles/use_case_pilot_study.html","id":"save-as-excel","dir":"Articles","previous_headings":"","what":"Save as Excel","title":"Typical Use of `eatATA`: a Pilot Study Example","text":"save item distribution blocks test forms, can use appendSolution() function. function simply merges new variables containing solution test assembly problem original item pool. Finally, solution exported excel file (.xlsx), can, example, achieved via eatAnalysis package, installed Github.","code":"out_df <- appendSolution(solver_raw, items = items, idCol = \"item\") devtools::install_github(\"beckerbenj/eatAnalysis\")  eatAnalysis::write_xlsx(out_df, filePath = \"example_excel.xlsx\",                         row.names = FALSE)"},{"path":"https://beckerbenj.github.io/eatATA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Benjamin Becker. Author, maintainer. Dries Debeer. Author.","code":""},{"path":"https://beckerbenj.github.io/eatATA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Becker B, Debeer D, Sachse K, Weirich S (2021). “Automated Test Assembly R: eatATA Package.” Psych, 3(2), 96–112. https://doi.org/10.3390/psych3020010.","code":"@Article{,   title = {Automated Test Assembly in R: The eatATA Package},   author = {Benjamin Becker and Dries Debeer and Karoline A. Sachse and Sebastian Weirich},   journal = {Psych},   year = {2021},   volume = {3},   number = {2},   pages = {96--112},   url = {https://doi.org/10.3390/psych3020010}, }"},{"path":[]},{"path":[]},{"path":"https://beckerbenj.github.io/eatATA/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Create Constraints for Small Test Assembly Problems","text":"eatATA provides small R interface mathematical optimization solvers specialized solving simple automated test assembly problems (ATA). Internally, sparse matrices used via Matrix package. Currently supported solvers GLPK, lpSolve, Symphony, Gurobi. See list implemented features feature come.","code":""},{"path":"https://beckerbenj.github.io/eatATA/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Create Constraints for Small Test Assembly Problems","text":"","code":"# Install eatATA from CRAN via install.packages(\"eatATA\")  # Install development version from GitHub via remotes::install_github(\"beckerbenj/eatATA\", build_vignettes = TRUE, dependencies = TRUE)"},{"path":"https://beckerbenj.github.io/eatATA/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Create Constraints for Small Test Assembly Problems","text":"extensive tutorial paper including variety use cases published : https://doi.org/10.3390/psych3020010. Additionally, set vignettes describing current functionality can found CRAN.","code":""},{"path":"https://beckerbenj.github.io/eatATA/index.html","id":"implemented-features","dir":"","previous_headings":"","what":"Implemented Features","title":"Create Constraints for Small Test Assembly Problems","text":"eatATA suitable automated test assembly fixed linear test forms multi-stage testing modules. example, following types constraints can set via eatATA: item overlap test forms complete item pool depletion categorical numerical constraints across test forms excluding items together booklet (item exclusions) force items test form (item inclusions) force set items included test forms various optimization constraints","code":""},{"path":"https://beckerbenj.github.io/eatATA/index.html","id":"outlook","dir":"","previous_headings":"","what":"Outlook","title":"Create Constraints for Small Test Assembly Problems","text":"Features might implemented future: taking account hierarchical stimulus-item structures adopting ROI framework access larger number solvers wish contribute package, please send email b.becker@iqb.hu-berlin.de.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/acrossFormsConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Constrain the sum of item values across multiple forms. — acrossFormsConstraint","title":"Constrain the sum of item values across multiple forms. — acrossFormsConstraint","text":"Create constraints related item values. , created constraints assure sum item values (itemValues) across test forms either () smaller equal (operator = \"<=\"), (b) equal (operator = \"=\"), (c) greater equal (operator = \">=\") chosen targetValue. Note length itemValues equal number length whichForms times whichItems.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/acrossFormsConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constrain the sum of item values across multiple forms. — acrossFormsConstraint","text":"","code":"acrossFormsConstraint(   nForms,   nItems = NULL,   operator = c(\"<=\", \"=\", \">=\"),   targetValue,   whichForms = seq_len(nForms),   whichItems = NULL,   itemIDs = NULL,   itemValues = NULL,   info_text = NULL )"},{"path":"https://beckerbenj.github.io/eatATA/reference/acrossFormsConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constrain the sum of item values across multiple forms. — acrossFormsConstraint","text":"nForms Number forms created. nItems Number items item pool [optional create itemIDs automatically]. operator character indicating operator used constraints, three possible values: \"<=\", \"=\", \">=\". See details information. targetValue target value. target sum item values across test forms. whichForms integer vector indicating across test forms sum constrained. Defaults test forms. whichItems vector indicating items constrained. Defaults items. itemIDs character vector item IDs correct ordering, NULL. itemValues vector item values sum across test forms constrained. item values repeated form. Defaults vector ones items pool. info_text character string length 1, used \"info\"-attribute resulting constraint-object.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/acrossFormsConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constrain the sum of item values across multiple forms. — acrossFormsConstraint","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/acrossFormsConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constrain the sum of item values across multiple forms. — acrossFormsConstraint","text":"","code":"## constraints to make sure that accross test form 1 and 3, only 4 items ##  of items 1:10 appear. Note that the constraint should be used in ##  in combination with constraining item overlap between the forms. constr1 <- combineConstraints(   acrossFormsConstraint(nForms = 3,                         operator = \"=\", targetValue = 4,                         whichForms = c(1, 3),                         itemValues = c(rep(1, 10), rep(0, 10)),                         itemIDs = 1:20),   itemUsageConstraint(nForms = 3, nItems = 20, operator = \"=\", targetValue = 1,                       itemIDs = 1:20)                     )  ## or alternatively constr2 <- combineConstraints(   acrossFormsConstraint(nForms = 3, nItems = 20,                         operator = \"=\", targetValue = 4,                         whichForms = c(1, 3),                         whichItems = 1:10,                         itemIDs = 1:20),   itemUsageConstraint(nForms = 3, nItems = 20, operator = \"=\", targetValue = 1,                       itemIDs = 1:20)                     )"},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeBlockExclusion.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze block exclusiveness — analyzeBlockExclusion","title":"Analyze block exclusiveness — analyzeBlockExclusion","text":"Use exclusion tuples information determine assembled test blocks exclusive.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeBlockExclusion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze block exclusiveness — analyzeBlockExclusion","text":"","code":"analyzeBlockExclusion(   solverOut,   items,   idCol,   exclusionTuples,   formName = \"form\" )"},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeBlockExclusion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze block exclusiveness — analyzeBlockExclusion","text":"solverOut Object created useSolver function. items Original data.frame containing information item level. idCol Column name items containing item IDs. used matching solver output. exclusionTuples data.frame two columns, containing tuples item IDs test forms exclusively. Must object used itemExclusionConstraint. formName character vector names give forms.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeBlockExclusion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze block exclusiveness — analyzeBlockExclusion","text":"data.frame block exclusions.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeBlockExclusion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze block exclusiveness — analyzeBlockExclusion","text":"exclusion tuples used assemble test forms (using itemExclusionConstraint function), resulting item blocks might also exclusive. Using initially used item exclusion tuples optimal solution given useSolver function determines, item blocks exclusive can together assembled test form.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeBlockExclusion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze block exclusiveness — analyzeBlockExclusion","text":"","code":"## Full workflow using itemExclusionTuples # Example data.frame items <- data.frame(ID = c(\"items1\", \"items2\", \"items3\", \"items4\"),                      exclusions = c(\"items2, items3\", NA, NA, NA),                      stringsAsFactors = FALSE)  # Create tuples exTuples2 <- itemTuples(items = items, idCol = \"ID\", infoCol = \"exclusions\",                     sepPattern = \", \")  #' ## Create constraints exclusion_constraint <- itemExclusionConstraint(nForms = 2, itemTuples = exTuples2,                                                 itemIDs = items$ID) depletion_constraint <- depletePoolConstraint(2, nItems = 4,                                                 itemIDs = items$ID) target_constraint <- minimaxObjective(nForms = 2,                                           itemValues = c(3, 1.5, 2, 4),                                           targetValue = 1,                                           itemIDs = items$ID)  opt_solution <- useSolver(list(exclusion_constraint, target_constraint,                                         depletion_constraint)) #> GLPK Simplex Optimizer 5.0 #> 12 rows, 9 columns, 36 non-zeros #>       0: obj =   0.000000000e+00 inf =   6.000e+00 (6) #>       8: obj =   4.250000000e+00 inf =   0.000e+00 (0) #> *    10: obj =   4.250000000e+00 inf =   0.000e+00 (0) #> OPTIMAL LP SOLUTION FOUND #> GLPK Integer Optimizer 5.0 #> 12 rows, 9 columns, 36 non-zeros #> 8 integer variables, all of which are binary #> Integer optimization begins... #> Long-step dual simplex will be used #> +    10: mip =     not found yet >=              -inf        (1; 0) #> +    14: >>>>>   6.000000000e+00 >=   4.250000000e+00  29.2% (2; 0) #> +    17: mip =   6.000000000e+00 >=     tree is empty   0.0% (0; 3) #> INTEGER OPTIMAL SOLUTION FOUND #> Optimal solution found.  analyzeBlockExclusion(opt_solution, items = items, idCol = \"ID\",                        exclusionTuples = exTuples2) #>   Name 1 Name 2 #> 1 form_1 form_2"},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeComplexBlockExclusion.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze complex block exclusiveness — analyzeComplexBlockExclusion","title":"Analyze complex block exclusiveness — analyzeComplexBlockExclusion","text":"Use exclusion tuples information independent test assembly problems determine assembled test blocks exclusive.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeComplexBlockExclusion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze complex block exclusiveness — analyzeComplexBlockExclusion","text":"","code":"analyzeComplexBlockExclusion(   solverOut_list,   items_list,   idCol,   exclusionTuples_list )"},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeComplexBlockExclusion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze complex block exclusiveness — analyzeComplexBlockExclusion","text":"solverOut_list List objects created useSolver. items_list List original data.frame containing information item level. idCol Column name items containing item IDs. used matching solver output. exclusionTuples_list List data.frames two columns, containing tuples item IDs test forms exclusively. Must objects used itemExclusionConstraint.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeComplexBlockExclusion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze complex block exclusiveness — analyzeComplexBlockExclusion","text":"data.frame block exclusions.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeComplexBlockExclusion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze complex block exclusiveness — analyzeComplexBlockExclusion","text":"exclusion tuples used assemble test forms (using itemExclusionConstraint function), resulting item blocks might also exclusive. Using initially used item exclusion tuples optimal solution given useSolver function determines, item blocks exclusive can together assembled test form. analyzeComplexBlockExclusion allows analyzing block exclusiveness separate test assembly problems. can useful test forms consist blocks containing different domains dimensions.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/analyzeComplexBlockExclusion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze complex block exclusiveness — analyzeComplexBlockExclusion","text":"","code":"## Full workflow using itemExclusionTuples # tbd"},{"path":"https://beckerbenj.github.io/eatATA/reference/appendSolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Append a useSolver output — appendSolution","title":"Append a useSolver output — appendSolution","text":"Append useSolver output successfully solved optimization problem initial item pool data.frame.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/appendSolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Append a useSolver output — appendSolution","text":"","code":"appendSolution(solverOut, items, idCol)"},{"path":"https://beckerbenj.github.io/eatATA/reference/appendSolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Append a useSolver output — appendSolution","text":"solverOut Object created useSolver function. items Original data.frame containing information item level. idCol Column name column number items containing item IDs. used matching solver output.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/appendSolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Append a useSolver output — appendSolution","text":"data.frame.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/appendSolution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Append a useSolver output — appendSolution","text":"function merges initial item pool information items solver output solverOut.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/appendSolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Append a useSolver output — appendSolution","text":"","code":"## Example item pool items <- data.frame(ID = 1:10, itemValues = c(-4, -4, -2, -2, -1, -1, 20, 20, 0, 0))  ## Test Assembly usage <- itemUsageConstraint(nForms = 2, operator = \"=\",                              targetValue = 1, itemIDs = items$ID) perForm <- itemsPerFormConstraint(nForms = 2, operator = \"=\",                                   targetValue = 5, itemIDs = items$ID) target <- minimaxObjective(nForms = 2,                                itemValues = items$itemValues,                                targetValue = 0, itemIDs = items$ID) sol <- useSolver(allConstraints = list(usage, perForm, target),                                   solver = \"lpSolve\") #> Optimal solution found.  ## Append Solution to existing item information out <- appendSolution(sol, items = items, idCol = 1)"},{"path":"https://beckerbenj.github.io/eatATA/reference/autoItemValuesMinMaxConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create single value constraints with minimum and maximum. — autoItemValuesMinMaxConstraint","title":"Create single value constraints with minimum and maximum. — autoItemValuesMinMaxConstraint","text":"itemValuesDeviationConstraint creates constraints related item parameter/value. autoItemValuesMixMax automatically determines appropriate targetValue calls itemValuesDeviationConstraint. function works (dichotomous) dummy indicators values 0 1.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/autoItemValuesMinMaxConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create single value constraints with minimum and maximum. — autoItemValuesMinMaxConstraint","text":"","code":"autoItemValuesMinMaxConstraint(   nForms,   itemValues,   testLength = NULL,   allowedDeviation = NULL,   relative = FALSE,   verbose = TRUE,   itemIDs = NULL )"},{"path":"https://beckerbenj.github.io/eatATA/reference/autoItemValuesMinMaxConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create single value constraints with minimum and maximum. — autoItemValuesMinMaxConstraint","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. testLength documented. allowedDeviation Numeric value length 1. much deviance allowed target values? relative allowedDeviation expressed proportion? verbose calculated values reported? itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/autoItemValuesMinMaxConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create single value constraints with minimum and maximum. — autoItemValuesMinMaxConstraint","text":"sparse matrix.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/autoItemValuesMinMaxConstraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create single value constraints with minimum and maximum. — autoItemValuesMinMaxConstraint","text":"Two scenarios possible automatically determining target value: () Either items selected property exactly distributed across test forms (b) possible. example 2 test forms 4 multiple choice items () 2 test forms 5 multiple choice items (b). (), tolerance level works exactly one expect. (b) tolerance level adapted, meaning tolerance level 0 example (b), allowed values 2 3 multiple choice items per test form. detailed documentation minimum maximum calculated see also computeTargetValues.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/autoItemValuesMinMaxConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create single value constraints with minimum and maximum. — autoItemValuesMinMaxConstraint","text":"","code":"autoItemValuesMinMaxConstraint(2, itemValues = c(0, 1, 0, 1)) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> The target value per test form is: 1 #> $A_binary #> 2 x 8 sparse Matrix of class \"dgCMatrix\" #>                      #> [1,] 0 1 0 1 . . . . #> [2,] . . . . 0 1 0 1 #>  #> $A_real #> NULL #>  #> $operators #> [1] \"=\" \"=\" #>  #> $d #> [1] 1 1 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 4 #> attr(,\"info\") #>   rowNr formNr itemNr   constraint #> 1     1      1     NA itemValues=1 #> 2     2      2     NA itemValues=1 #> attr(,\"itemIDs\") #> [1] \"it1\" \"it2\" \"it3\" \"it4\""},{"path":"https://beckerbenj.github.io/eatATA/reference/calculateIIF.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Item Information Function — calculateIIF","title":"Calculate Item Information Function — calculateIIF","text":"Calculate item information function given item parameters 1PL, 2PL 3PL IRT model.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/calculateIIF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Item Information Function — calculateIIF","text":"","code":"calculateIIF(A = rep(1, length(B)), B, C = rep(0, length(B)), theta, D = 1.7)"},{"path":"https://beckerbenj.github.io/eatATA/reference/calculateIIF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Item Information Function — calculateIIF","text":"Vector discrimination parameters. B Vector difficulty parameters. C Vector pseudo-guessing parameters. theta Vector time intensity parameters. D constant used. Defaults 1.7.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/calculateIIF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Item Information Function — calculateIIF","text":"matrix, columns different theta rows different items","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/calculateIIF.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Item Information Function — calculateIIF","text":"van der Linden, W. J. (2005). Linear models optimal test design. New York, NY: Springer.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/calculateIIF.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Item Information Function — calculateIIF","text":"","code":"# TIF for a single item (2PL model) calculateIIF(A = 0.8, B = 1.1, theta = 0) #>        theta=0 #> [1,] 0.2765624  # TIF for multiple items (1PL model) calculateIIF(B = c(1.1, 0.8, 0.5), theta = 0) #>        theta=0 #> [1,] 0.3343971 #> [2,] 0.4697007 #> [3,] 0.6062435  # TIF for multiple theta-values (3PL model) calculateIIF(B = -0.5, C = 0.25, theta = c(-1, 0, 1)) #>      theta=-1   theta=0   theta=1 #> [1,] 0.286882 0.4107883 0.1428265  # TIF for multiple items and multiple ability levels (2PL model) calculateIIF(A = c(0.7, 1.1, 0.8), B = c(1.1, 0.8, 0.5),             theta = c(-1, 0, 1)) #>        theta=-1   theta=0   theta=1 #> [1,] 0.09935811 0.2371010 0.3527746 #> [2,] 0.11281424 0.5228757 0.8443530 #> [3,] 0.18833807 0.4128116 0.4128116"},{"path":"https://beckerbenj.github.io/eatATA/reference/cappedMaximinObjective.html","id":null,"dir":"Reference","previous_headings":"","what":"Capped Maximin Constraint. — cappedMaximinObjective","title":"Capped Maximin Constraint. — cappedMaximinObjective","text":"Create maximin-constraints related item parameter/value. , created constraints can used maximize minimal sum item values (itemValues), time automatically setting ideal upper limit overflow. specifically, capped minimax method described Luo (2020) used.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/cappedMaximinObjective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capped Maximin Constraint. — cappedMaximinObjective","text":"","code":"cappedMaximinObjective(   nForms,   itemValues,   weight = 1,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/cappedMaximinObjective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capped Maximin Constraint. — cappedMaximinObjective","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. weight weight real-valued variable(s). Useful multiple constraints combined. used implications well understood. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/cappedMaximinObjective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capped Maximin Constraint. — cappedMaximinObjective","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/cappedMaximinObjective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Capped Maximin Constraint. — cappedMaximinObjective","text":"Xiao Luo (2020). Automated Test Assembly Mixed-Integer Programming: Effects Modeling Approaches Solvers. Journal Educational Measurement, 57(4), 547-565. doi:10.1111/jedm.12262","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/cappedMaximinObjective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capped Maximin Constraint. — cappedMaximinObjective","text":"","code":"# constraint that minimizes the maximum difference per test form value and a #   target value of 0 cappedMaximinObjective(nForms = 2, itemValues = rep(-2:2, 2)) #> $A_binary #> 4 x 20 sparse Matrix of class \"dgCMatrix\" #>                                                      #> [1,] -2 -1 0 1 2 -2 -1 0 1 2  .  . . . .  .  . . . . #> [2,]  .  . . . .  .  . . . . -2 -1 0 1 2 -2 -1 0 1 2 #> [3,] -2 -1 0 1 2 -2 -1 0 1 2  .  . . . .  .  . . . . #> [4,]  .  . . . .  .  . . . . -2 -1 0 1 2 -2 -1 0 1 2 #>  #> $A_real #>      [,1] [,2] #> [1,]   -1    0 #> [2,]   -1    0 #> [3,]   -1   -1 #> [4,]   -1   -1 #>  #> $operators #> [1] \">=\" \">=\" \"<=\" \"<=\" #>  #> $d #> [1] 0 0 0 0 #>  #> $c_binary #> NULL #>  #> $c_real #> [1]  1 -1 #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"sense\") #> [1] \"max\" #> attr(,\"info\") #>   rowNr formNr itemNr               constraint #> 1     1      1     NA cappedMaximin_lowerBound #> 2     2      2     NA cappedMaximin_lowerBound #> 3     3      1     NA cappedMaximin_upperBound #> 4     4      2     NA cappedMaximin_upperBound #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/combineConstraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine constraints — combineConstraints","title":"Combine constraints — combineConstraints","text":"Combine multiple constraint-objects one constraint object.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/combineConstraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine constraints — combineConstraints","text":"","code":"combineConstraints(..., message = TRUE)"},{"path":"https://beckerbenj.github.io/eatATA/reference/combineConstraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine constraints — combineConstraints","text":"... multiple constraint-objects list multiple constraint-objects message logical indicating whether message given one constraint object combined.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/combineConstraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine constraints — combineConstraints","text":"data.frame block exclusions.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/combineConstraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine constraints — combineConstraints","text":"","code":"combineConstraints(  itemValuesConstraint(2, 1:10, operator = \">=\", targetValue = 4),  itemValuesConstraint(2, 1:10, operator = \"<=\", targetValue = 6) ) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 4 x 20 sparse Matrix of class \"dgCMatrix\" #>                                                #> [1,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [2,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #> [3,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [4,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #>  #> $A_real #> NULL #>  #> $operators #> [1] \">=\" \">=\" \"<=\" \"<=\" #>  #> $d #> [1] 4 4 6 6 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"info\") #>   rowNr formNr itemNr constraint #> 1     1      1     NA    1:10>=4 #> 2     2      2     NA    1:10>=4 #> 3     3      1     NA    1:10<=6 #> 4     4      2     NA    1:10<=6 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/computeTargetValues.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute target values based on the item pool. — computeTargetValues","title":"Compute target values based on the item pool. — computeTargetValues","text":"Compute target values item values/categories based number items item pool, number test forms assemble number items test form (.e., test length).","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/computeTargetValues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute target values based on the item pool. — computeTargetValues","text":"","code":"computeTargetValues(   itemValues,   nForms,   testLength = NULL,   allowedDeviation = NULL,   relative = FALSE )  # Default S3 method computeTargetValues(   itemValues,   nForms,   testLength = NULL,   allowedDeviation = NULL,   relative = FALSE )  # S3 method for class 'factor' computeTargetValues(   itemValues,   nForms,   testLength = NULL,   allowedDeviation = NULL,   relative = FALSE )"},{"path":"https://beckerbenj.github.io/eatATA/reference/computeTargetValues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute target values based on the item pool. — computeTargetValues","text":"itemValues Item parameter/values sum per test form constrained. nForms Number forms created. testLength documented. allowedDeviation Numeric value length 1. much deviance allowed target values? relative allowedDeviation expressed proportion?","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/computeTargetValues.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute target values based on the item pool. — computeTargetValues","text":"vector matrix target values (see details)","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/computeTargetValues.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute target values based on the item pool. — computeTargetValues","text":"numerical categorical item values, target values item pool average scaled ratio items forms items item pool. behavior function changes depending class itemValues. itemValues numerical vector, allowedDeviation NULL (default), one target value computed. value used targetConstraint-function. Otherwise (.e., allowedDeviation numerical value), target computed, minimal maximal (target)value returned, based allowed deviation. relative == TRUE allowed deviation expressed proportion. case minimal maximal values computed proportionally. itemValues factor, assumed item values item categories, hence whole valued frequencies returned. precise, matrix minimal maximal target frequencies every level factor returned. allowedDeviation NULL, difference minimal maximal value one (zero). consequence, dummy-item values best specified factor (see examples).","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/computeTargetValues.html","id":"methods-by-class-","dir":"Reference","previous_headings":"","what":"Methods (by class)","title":"Compute target values based on the item pool. — computeTargetValues","text":"computeTargetValues(default): compute target values computeTargetValues(factor): compute target frequencies item categories","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/computeTargetValues.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute target values based on the item pool. — computeTargetValues","text":"","code":"## Assume an item pool with 50 items with random item information values (iif) for ## a given ability value. set.seed(50) itemInformations <- runif(50, 0.5, 3)  ## The target value for the test information value (i.e., sum of the item ## informations) when three test forms of 10 items are assembled is: computeTargetValues(itemInformations, nForms = 3, testLength = 10) #> [1] 16.18879  ## The minimum and maximum test iformation values for an allowed deviation of ## 10 percent are: computeTargetValues(itemInformations, nForms = 3, allowedDeviation = .10,    relative = TRUE, testLength = 10) #>      min      max  #> 14.56991 17.80767    ## items_vera$MC is dummy variable indication which items in the pool are multiple choise str(items_vera$MC) #>  num [1:80] 0 0 0 0 0 0 0 0 0 1 ...  ## when used as a numerical vector, the dummy is not treated as a categorical ## indicator, but rather as a numerical value. computeTargetValues(items_vera$MC, nForms = 14) #> [1] 1.5 computeTargetValues(items_vera$MC, nForms = 14, allowedDeviation = 1) #> min max  #> 0.5 2.5   ## Therefore, it is best to convert dummy variables into a factor, so that ## automatically freqyencies are returned MC_factor <- factor(items_vera$MC, labels = c(\"not MC\", \"MC\")) computeTargetValues(MC_factor, nForms = 14) #>        min max #> not MC   4   5 #> MC       1   2 computeTargetValues(MC_factor, nForms = 3) #>        min max #> not MC  19  20 #> MC       7   7  ## The computed minimum and maximum frequencies can be used to create contstraints. MC_ranges <- computeTargetValues(MC_factor, nForms = 3) itemCategoryRangeConstraint(3, MC_factor, range = MC_ranges) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 12 x 240 sparse Matrix of class \"dgCMatrix\" #>                                                                                 #>  [1,] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 1 1 1 1 1 1 #>  [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 #>  [5,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 1 1 1 1 1 1 #>  [8,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 #> [11,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1 1 0 1 #>  [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 #>  [5,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1 1 0 1 #>  [8,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 #> [11,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] 1 1 1 1 0 1 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 #>  [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] 0 0 0 0 1 0 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] . . . . . . . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 #>  [7,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] 1 1 1 1 0 1 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 #> [10,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] 0 0 0 0 1 0 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] . . . . . . . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 #>                                                                                 #>  [1,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 #>  [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 #>  [7,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 #> [10,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 #>                                           #>  [1,] . . . . . . . . . . . . . . . . . . #>  [2,] . . . . . . . . . . . . . . . . . . #>  [3,] 1 0 1 1 1 1 1 1 1 1 0 1 0 1 1 1 1 1 #>  [4,] . . . . . . . . . . . . . . . . . . #>  [5,] . . . . . . . . . . . . . . . . . . #>  [6,] 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 #>  [7,] . . . . . . . . . . . . . . . . . . #>  [8,] . . . . . . . . . . . . . . . . . . #>  [9,] 1 0 1 1 1 1 1 1 1 1 0 1 0 1 1 1 1 1 #> [10,] . . . . . . . . . . . . . . . . . . #> [11,] . . . . . . . . . . . . . . . . . . #> [12,] 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 #>  #> $A_real #> NULL #>  #> $operators #>  [1] \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" #>  #> $d #> not MC not MC not MC     MC     MC     MC not MC not MC not MC     MC     MC  #>     19     19     19      7      7      7     20     20     20      7      7  #>     MC  #>      7  #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 3 #> attr(,\"nItems\") #> [1] 80 #> attr(,\"info\") #>    rowNr formNr itemNr    constraint #> 1      1      1     NA MC_factor>=19 #> 2      2      2     NA MC_factor>=19 #> 3      3      3     NA MC_factor>=19 #> 4      4      1     NA  MC_factor>=7 #> 5      5      2     NA  MC_factor>=7 #> 6      6      3     NA  MC_factor>=7 #> 7      7      1     NA MC_factor<=20 #> 8      8      2     NA MC_factor<=20 #> 9      9      3     NA MC_factor<=20 #> 10    10      1     NA  MC_factor<=7 #> 11    11      2     NA  MC_factor<=7 #> 12    12      3     NA  MC_factor<=7 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\" #> [11] \"it11\" \"it12\" \"it13\" \"it14\" \"it15\" \"it16\" \"it17\" \"it18\" \"it19\" \"it20\" #> [21] \"it21\" \"it22\" \"it23\" \"it24\" \"it25\" \"it26\" \"it27\" \"it28\" \"it29\" \"it30\" #> [31] \"it31\" \"it32\" \"it33\" \"it34\" \"it35\" \"it36\" \"it37\" \"it38\" \"it39\" \"it40\" #> [41] \"it41\" \"it42\" \"it43\" \"it44\" \"it45\" \"it46\" \"it47\" \"it48\" \"it49\" \"it50\" #> [51] \"it51\" \"it52\" \"it53\" \"it54\" \"it55\" \"it56\" \"it57\" \"it58\" \"it59\" \"it60\" #> [61] \"it61\" \"it62\" \"it63\" \"it64\" \"it65\" \"it66\" \"it67\" \"it68\" \"it69\" \"it70\" #> [71] \"it71\" \"it72\" \"it73\" \"it74\" \"it75\" \"it76\" \"it77\" \"it78\" \"it79\" \"it80\"  ## When desired, the automatically computed range can be adjusted by hand. This ##  can be of use when only a limited set of the categories should be constrained. ##  For instance, when only the multiple-choice items should be constrained, and ##  the non-multiple-choice items should not be constrained, the minimum and ##  maximum value can be set to a very small and a very high value, respectively. ##  Or to other sensible values. MC_ranges[\"not MC\", ] <- c(0, 40) MC_ranges #>        min max #> not MC   0  40 #> MC       7   7 itemCategoryRangeConstraint(3, MC_factor, range = MC_ranges) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 12 x 240 sparse Matrix of class \"dgCMatrix\" #>                                                                                 #>  [1,] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 1 1 1 1 1 1 #>  [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 #>  [5,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 1 1 1 1 1 1 #>  [8,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 #> [11,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1 1 0 1 #>  [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 #>  [5,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1 1 0 1 #>  [8,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 #> [11,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 0 #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 0 1 #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [7,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [10,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                                                 #>  [1,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] 1 1 1 1 0 1 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 #>  [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] 0 0 0 0 1 0 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] . . . . . . . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 #>  [7,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] 1 1 1 1 0 1 0 1 1 1 1 1 . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 1 #> [10,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] 0 0 0 0 1 0 1 0 0 0 0 0 . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] . . . . . . . . . . . . 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 1 0 #>                                                                                 #>  [1,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [3,] 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 #>  [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [5,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 #>  [7,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>  [9,] 1 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 0 1 #> [10,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [11,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #> [12,] 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 #>                                           #>  [1,] . . . . . . . . . . . . . . . . . . #>  [2,] . . . . . . . . . . . . . . . . . . #>  [3,] 1 0 1 1 1 1 1 1 1 1 0 1 0 1 1 1 1 1 #>  [4,] . . . . . . . . . . . . . . . . . . #>  [5,] . . . . . . . . . . . . . . . . . . #>  [6,] 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 #>  [7,] . . . . . . . . . . . . . . . . . . #>  [8,] . . . . . . . . . . . . . . . . . . #>  [9,] 1 0 1 1 1 1 1 1 1 1 0 1 0 1 1 1 1 1 #> [10,] . . . . . . . . . . . . . . . . . . #> [11,] . . . . . . . . . . . . . . . . . . #> [12,] 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 #>  #> $A_real #> NULL #>  #> $operators #>  [1] \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" #>  #> $d #> not MC not MC not MC     MC     MC     MC not MC not MC not MC     MC     MC  #>      0      0      0      7      7      7     40     40     40      7      7  #>     MC  #>      7  #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 3 #> attr(,\"nItems\") #> [1] 80 #> attr(,\"info\") #>    rowNr formNr itemNr    constraint #> 1      1      1     NA  MC_factor>=0 #> 2      2      2     NA  MC_factor>=0 #> 3      3      3     NA  MC_factor>=0 #> 4      4      1     NA  MC_factor>=7 #> 5      5      2     NA  MC_factor>=7 #> 6      6      3     NA  MC_factor>=7 #> 7      7      1     NA MC_factor<=40 #> 8      8      2     NA MC_factor<=40 #> 9      9      3     NA MC_factor<=40 #> 10    10      1     NA  MC_factor<=7 #> 11    11      2     NA  MC_factor<=7 #> 12    12      3     NA  MC_factor<=7 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\" #> [11] \"it11\" \"it12\" \"it13\" \"it14\" \"it15\" \"it16\" \"it17\" \"it18\" \"it19\" \"it20\" #> [21] \"it21\" \"it22\" \"it23\" \"it24\" \"it25\" \"it26\" \"it27\" \"it28\" \"it29\" \"it30\" #> [31] \"it31\" \"it32\" \"it33\" \"it34\" \"it35\" \"it36\" \"it37\" \"it38\" \"it39\" \"it40\" #> [41] \"it41\" \"it42\" \"it43\" \"it44\" \"it45\" \"it46\" \"it47\" \"it48\" \"it49\" \"it50\" #> [51] \"it51\" \"it52\" \"it53\" \"it54\" \"it55\" \"it56\" \"it57\" \"it58\" \"it59\" \"it60\" #> [61] \"it61\" \"it62\" \"it63\" \"it64\" \"it65\" \"it66\" \"it67\" \"it68\" \"it69\" \"it70\" #> [71] \"it71\" \"it72\" \"it73\" \"it74\" \"it75\" \"it76\" \"it77\" \"it78\" \"it79\" \"it80\""},{"path":"https://beckerbenj.github.io/eatATA/reference/depletePoolConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Use complete item pool. — depletePoolConstraint","title":"Use complete item pool. — depletePoolConstraint","text":"Creates constraints assure every item item pool used (least) . Essentially wrapper around itemUsageConstraint.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/depletePoolConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use complete item pool. — depletePoolConstraint","text":"","code":"depletePoolConstraint(nForms, nItems = NULL, itemIDs = NULL)"},{"path":"https://beckerbenj.github.io/eatATA/reference/depletePoolConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use complete item pool. — depletePoolConstraint","text":"nForms Number forms created. nItems Number items item pool [optional create itemIDs automatically]. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/depletePoolConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use complete item pool. — depletePoolConstraint","text":"sparse matrix.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/depletePoolConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use complete item pool. — depletePoolConstraint","text":"","code":"depletePoolConstraint(2, itemIDs = 1:10) #> $A_binary #> 10 x 20 sparse Matrix of class \"dgCMatrix\" #>                                               #>  [1,] 1 . . . . . . . . . 1 . . . . . . . . . #>  [2,] . 1 . . . . . . . . . 1 . . . . . . . . #>  [3,] . . 1 . . . . . . . . . 1 . . . . . . . #>  [4,] . . . 1 . . . . . . . . . 1 . . . . . . #>  [5,] . . . . 1 . . . . . . . . . 1 . . . . . #>  [6,] . . . . . 1 . . . . . . . . . 1 . . . . #>  [7,] . . . . . . 1 . . . . . . . . . 1 . . . #>  [8,] . . . . . . . 1 . . . . . . . . . 1 . . #>  [9,] . . . . . . . . 1 . . . . . . . . . 1 . #> [10,] . . . . . . . . . 1 . . . . . . . . . 1 #>  #> $A_real #> NULL #>  #> $operators #>  [1] \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" #>  #> $d #>  [1] 1 1 1 1 1 1 1 1 1 1 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"info\") #>    rowNr formNr itemNr        constraint #> 1      1     NA      1 rep(1, nForms)>=1 #> 2      2     NA      2 rep(1, nForms)>=1 #> 3      3     NA      3 rep(1, nForms)>=1 #> 4      4     NA      4 rep(1, nForms)>=1 #> 5      5     NA      5 rep(1, nForms)>=1 #> 6      6     NA      6 rep(1, nForms)>=1 #> 7      7     NA      7 rep(1, nForms)>=1 #> 8      8     NA      8 rep(1, nForms)>=1 #> 9      9     NA      9 rep(1, nForms)>=1 #> 10    10     NA     10 rep(1, nForms)>=1 #> attr(,\"itemIDs\") #>  [1]  1  2  3  4  5  6  7  8  9 10"},{"path":"https://beckerbenj.github.io/eatATA/reference/dummiesToFactor.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dummy variables to factor. — dummiesToFactor","title":"Convert dummy variables to factor. — dummiesToFactor","text":"Convert multiple dummy variables single factor variable.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/dummiesToFactor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dummy variables to factor. — dummiesToFactor","text":"","code":"dummiesToFactor(dat, dummies, facVar, nameEmptyCategory = \"_none_\")"},{"path":"https://beckerbenj.github.io/eatATA/reference/dummiesToFactor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dummy variables to factor. — dummiesToFactor","text":"dat data.frame. dummies Character vector containing names dummy variables data.frame. facVar Name factor variable, created. nameEmptyCategory character length 1 defines name cases dummy equal one.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/dummiesToFactor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dummy variables to factor. — dummiesToFactor","text":"data.frame containing newly created factor.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/dummiesToFactor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert dummy variables to factor. — dummiesToFactor","text":"content single factor variable can alternatively stored multiple dichotomous dummy variables coded 0/1 NA/1. 1 always refer \"category applies\". function requires factor levels exclusive (.e. one factor level applies per row.).","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/dummiesToFactor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert dummy variables to factor. — dummiesToFactor","text":"","code":"# Example data set tdat <- data.frame(ID = 1:3, d1=c(1, 0, 0), d2 = c(0, 1, 0), d3 = c(0, 0, 1))  dummiesToFactor(tdat, dummies = c(\"d1\", \"d2\", \"d3\"), facVar = \"newFac\") #>   ID d1 d2 d3 newFac #> 1  1  1  0  0     d1 #> 2  2  0  1  0     d2 #> 3  3  0  0  1     d3"},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"Calculate first second cumulants (.e., mean variance) item response time distributions given item parameters three-parameter log-normal model (3PLN) response times.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"","code":"getMean3PLN(lambda, phi = rep(1, length(lambda)), zeta, sdEpsi)  getMean2PLN(lambda, zeta, sdEpsi)  getVar3PLN(lambda, phi = rep(1, length(lambda)), zeta, sdEpsi)  getVar2PLN(lambda, zeta, sdEpsi)"},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"lambda Vector time intensity parameters. phi [optional] Vector speed sensitivity parameters. zeta Vector person speed parameters. sdEpsi Vector item specific residual variances.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"matrix either mean variance response time distributions,        columns different zeta rows different items","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"Calculate first second cumulant two-parameter log-normal (2PLN) model response times according van der Linden (2006) 3PLN according Klein Entink et al. (2009). speed sensitivity parameter phi 3PLN equals 1, model reduces 2PLN, yet different parameterization item specific residual variance sdEpsi compared van der Linden (2006). cumulants computed one speed parameters, one sets item parameters. calculation based Fenton (1960). model van der Linden (2006), calculation first introduced van der Linden (2011).","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"getMean3PLN(): Calculate mean 3PLN getMean2PLN(): Calculate mean 2PLN getVar3PLN(): Calculate variance 3PLN getVar2PLN(): Calculate variance 2PLN","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"Fenton, L. (1960). sum log-normal probability distributions scatter transmission systems. IRE Transactions Communication Systems, 8, 57-67. Klein Entink, R. H., Fox, J.-P., & van der Linden, W. J. (2009). multivariate multilevel approach modeling accuracy speed test takers. Psychometrika, 74(1), 21-48. van der Linden, W. J. (2006). lognormal model response times test items. Journal Educational Behavioral Statistics, 31(2), 181-204. van der Linden, W. J. (2011). Test design speededness. Journal Educational Measurement, 48(1), 44-60.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/getMean3PLN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Cumulants Lognormal Response Time Distribution — getMean3PLN","text":"","code":"# expected RT for a single item (van der Linden model) getMean2PLN(lambda = 3.8, zeta = 0, sdEpsi = 0.3) #>        zeta=0 #> [1,] 46.75868 getVar2PLN(lambda = 3.8, zeta = 0, sdEpsi = 0.3) #>        zeta=0 #> [1,] 205.9003  # expected RT for multiple items (van der Linden model) getMean2PLN(lambda = c(4.1, 3.8, 3.5), zeta = 0,                    sdEpsi = c(0.3, 0.4, 0.2)) #>        zeta=0 #> [1,] 63.11762 #> [2,] 48.42422 #> [3,] 33.78443 getVar2PLN(lambda = c(4.1, 3.8, 3.5), zeta = 0,                    sdEpsi = c(0.3, 0.4, 0.2)) #>         zeta=0 #> [1,] 375.17473 #> [2,] 406.86644 #> [3,]  46.58091  # expected RT for multiple items and multiple spped levels (Klein Entink model) getMean3PLN(lambda = c(3.7, 4.1, 3.8), phi = c(1.1, 0.8, 0.5),                     zeta = c(-1, 0, 1), sdEpsi = c(0.3, 0.4, 0.2)) #>        zeta=-1   zeta=0   zeta=1 #> [1,] 127.10328 42.30901 14.08345 #> [2,] 145.47438 65.36585 29.37077 #> [3,]  75.18863 45.60421 27.66035 getVar3PLN(lambda = c(3.7, 4.1, 3.8), phi = c(1.1, 0.8, 0.5),                     zeta = c(-1, 0, 1), sdEpsi = c(0.3, 0.4, 0.2)) #>        zeta=-1    zeta=0    zeta=1 #> [1,] 1521.4086 168.57687  18.67885 #> [2,] 3671.9751 741.35899 149.67780 #> [3,]  230.7168  84.87596  31.22412"},{"path":"https://beckerbenj.github.io/eatATA/reference/get_mean_3PLN.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Cumulants Lognormal Response Time Distribution — calculateExpectedRT","title":"Calculate Cumulants Lognormal Response Time Distribution — calculateExpectedRT","text":"functions deprecated. See getMean3PLN getVar3PLN instead.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/get_mean_3PLN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Cumulants Lognormal Response Time Distribution — calculateExpectedRT","text":"","code":"calculateExpectedRT(lambda, phi, zeta, sdEpsi)  calculateExpectedRTvar(lambda, phi, zeta, sdEpsi)"},{"path":"https://beckerbenj.github.io/eatATA/reference/get_mean_3PLN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Cumulants Lognormal Response Time Distribution — calculateExpectedRT","text":"lambda Vector time intensity parameters. phi [optional] Vector speed sensitivity parameters. zeta Vector person speed parameters. sdEpsi Vector item specific residual variances.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/get_mean_3PLN.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Calculate Cumulants Lognormal Response Time Distribution — calculateExpectedRT","text":"calculateExpectedRT(): Calculate mean 3PLN calculateExpectedRTvar(): Calculate mean 2PLN","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/inspectSolution.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect a useSolver output — inspectSolution","title":"Inspect a useSolver output — inspectSolution","text":"Process useSolver output successfully solved optimization problem list becomes humanly readable.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/inspectSolution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect a useSolver output — inspectSolution","text":"","code":"inspectSolution(   solverOut,   items,   idCol,   colNames = names(items),   colSums = TRUE )"},{"path":"https://beckerbenj.github.io/eatATA/reference/inspectSolution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect a useSolver output — inspectSolution","text":"solverOut Object created useSolver function. items Original data.frame containing information item level. idCol Column name items containing item IDs. used matching solver output. colNames columns used items data.frame? colSums column sums calculated output? works columns numeric.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/inspectSolution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inspect a useSolver output — inspectSolution","text":"list assembled blocks entries. Rows individual items. final row added, containing sums column.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/inspectSolution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inspect a useSolver output — inspectSolution","text":"function merges initial item pool information items solver output solverOut. Relevant columns can selected via colNames. Column sums within test forms calculated possible colSum set TRUE.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/inspectSolution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect a useSolver output — inspectSolution","text":"","code":"## Example item pool items <- data.frame(ID = 1:10, itemValues = c(-4, -4, -2, -2, -1, -1, 20, 20, 0, 0))  ## Test Assembly usage <- itemUsageConstraint(nForms = 2, operator = \"=\",                              targetValue = 1, itemIDs = items$ID) perForm <- itemsPerFormConstraint(nForms = 2, operator = \"=\",                                   targetValue = 5, itemIDs = items$ID) target <- minimaxObjective(nForms = 2,                                itemValues = items$itemValues,                                targetValue = 0, itemIDs = items$ID) sol <- useSolver(allConstraints = list(usage, perForm, target),                                   solver = \"lpSolve\") #> Optimal solution found.  ## Inspect Solution out <- inspectSolution(sol, items = items, idCol = 1, colNames = \"itemValues\")"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create item category constraints. — itemCategoryConstraint","title":"Create item category constraints. — itemCategoryConstraint","text":"Create constraints related item categories/groupings (represented itemCategories). , created constraints assure number items category per test form either () smaller equal (operator = \"<=\"), (b) equal (operator = \"=\"), (c) greater equal (operator = \">=\") corresponding targetValues.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create item category constraints. — itemCategoryConstraint","text":"","code":"itemCategoryConstraint(   nForms,   itemCategories,   operator = c(\"<=\", \"=\", \">=\"),   targetValues,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemCategories) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create item category constraints. — itemCategoryConstraint","text":"nForms Number forms created. itemCategories factor representing categories/grouping items operator character indicating operator used constraints, three possible values: \"<=\", \"=\", \">=\". See details information. targetValues integer vector representing target number per category. order target values correspond order levels factor itemCategory. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create item category constraints. — itemCategoryConstraint","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create item category constraints. — itemCategoryConstraint","text":"","code":"## constraints to make sure that there are at least 3 items of each item type ## in each test form nItems <- 30 item_type <- factor(sample(1:3, size = nItems, replace = TRUE)) itemCategoryConstraint(2, item_type, \">=\", targetValues = c(1, 3, 2)) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 6 x 60 sparse Matrix of class \"dgCMatrix\" #>                                                                                #> [1,] 1 1 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 1 . . . . . . . #> [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1 0 1 0 0 0 #> [3,] 0 0 1 0 1 1 1 0 1 0 0 0 0 0 0 1 0 0 0 1 1 1 1 0 1 0 0 0 1 0 . . . . . . . #> [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 0 0 1 0 1 1 1 #> [5,] 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 1 0 0 . . . . . . . #> [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 0 0 0 0 0 0 0 #>                                                    #> [1,] . . . . . . . . . . . . . . . . . . . . . . . #> [2,] 1 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 1 #> [3,] . . . . . . . . . . . . . . . . . . . . . . . #> [4,] 0 1 0 0 0 0 0 0 1 0 0 0 1 1 1 1 0 1 0 0 0 1 0 #> [5,] . . . . . . . . . . . . . . . . . . . . . . . #> [6,] 0 0 1 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 1 0 0 #>  #> $A_real #> NULL #>  #> $operators #> [1] \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" #>  #> $d #> [1] 1 1 3 3 2 2 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 30 #> attr(,\"info\") #>   rowNr formNr itemNr   constraint #> 1     1      1     NA item_type>=1 #> 2     2      2     NA item_type>=1 #> 3     3      1     NA item_type>=3 #> 4     4      2     NA item_type>=3 #> 5     5      1     NA item_type>=2 #> 6     6      2     NA item_type>=2 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\" #> [11] \"it11\" \"it12\" \"it13\" \"it14\" \"it15\" \"it16\" \"it17\" \"it18\" \"it19\" \"it20\" #> [21] \"it21\" \"it22\" \"it23\" \"it24\" \"it25\" \"it26\" \"it27\" \"it28\" \"it29\" \"it30\""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryRangeConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","title":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","text":"itemCategoriesRange, itemCategoriesMin, itemCategoriesMax create constraints related item categories/groupings (represented itemCategories). , created constraints assure number items category per test form either smaller equal specified max, greater equal min range.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryRangeConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","text":"","code":"itemCategoryRangeConstraint(   nForms,   itemCategories,   range,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemCategories) )  itemCategoryMinConstraint(   nForms,   itemCategories,   min,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemCategories) )  itemCategoryMaxConstraint(   nForms,   itemCategories,   max,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemCategories) )  itemCategoryDeviationConstraint(   nForms,   itemCategories,   targetValues,   allowedDeviation,   relative = FALSE,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemCategories) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryRangeConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","text":"nForms Number forms created. itemCategories factor representing categories/grouping items range matrix two columns representing minimal maximum frequency items level/category itemCategories whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL. min minimal sum itemValues per test form max minimal sum itemValues per test form targetValues integer vector representing target number per category. order target values correspond order levels factor itemCategory. allowedDeviation maximum allowed deviation targetValue relative logical expressing whether allowedDeviation interpreted proportion targetValue","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryRangeConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","text":"sparse matrix.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryRangeConstraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","text":"itemCategoriesDeviation also constrains minimal maximal value number items category per test form, based chosen targetValues, maximal allowed deviations (.e., allowedDeviation) targetValues.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryRangeConstraint.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","text":"itemCategoryMinConstraint(): constrain minimum value itemCategoryMaxConstraint(): constrain maximum value itemCategoryDeviationConstraint(): constrain distance form targetValues","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemCategoryRangeConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create item category constraints with minimum and maximum. — itemCategoryRangeConstraint","text":"","code":"## constraints to make sure that there are at least 2 and maximally 4 ##  items of each item type in each test form nItems <- 30 item_type <- factor(sample(1:3, size = nItems, replace = TRUE)) itemCategoryRangeConstraint(2, item_type, range = cbind(min = rep(2, 3), max = rep(4, 3))) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 12 x 60 sparse Matrix of class \"dgCMatrix\" #>                                                                                 #>  [1,] 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 . . . . . . . #>  [2,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 0 0 0 0 0 0 0 #>  [3,] 1 1 1 0 0 0 1 1 0 1 0 1 1 0 1 1 0 1 0 0 0 0 1 0 0 0 1 1 0 0 . . . . . . . #>  [4,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1 1 0 0 0 1 #>  [5,] 0 0 0 1 1 1 0 0 1 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 1 . . . . . . . #>  [6,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 0 0 0 1 1 1 0 #>  [7,] 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 . . . . . . . #>  [8,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 0 0 0 0 0 0 0 #>  [9,] 1 1 1 0 0 0 1 1 0 1 0 1 1 0 1 1 0 1 0 0 0 0 1 0 0 0 1 1 0 0 . . . . . . . #> [10,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1 1 0 0 0 1 #> [11,] 0 0 0 1 1 1 0 0 1 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 1 . . . . . . . #> [12,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 0 0 0 1 1 1 0 #>                                                     #>  [1,] . . . . . . . . . . . . . . . . . . . . . . . #>  [2,] 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 #>  [3,] . . . . . . . . . . . . . . . . . . . . . . . #>  [4,] 1 0 1 0 1 1 0 1 1 0 1 0 0 0 0 1 0 0 0 1 1 0 0 #>  [5,] . . . . . . . . . . . . . . . . . . . . . . . #>  [6,] 0 1 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 1 #>  [7,] . . . . . . . . . . . . . . . . . . . . . . . #>  [8,] 0 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 0 #>  [9,] . . . . . . . . . . . . . . . . . . . . . . . #> [10,] 1 0 1 0 1 1 0 1 1 0 1 0 0 0 0 1 0 0 0 1 1 0 0 #> [11,] . . . . . . . . . . . . . . . . . . . . . . . #> [12,] 0 1 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 1 1 #>  #> $A_real #> NULL #>  #> $operators #>  [1] \">=\" \">=\" \">=\" \">=\" \">=\" \">=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" #>  #> $d #>  [1] 2 2 2 2 2 2 4 4 4 4 4 4 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 30 #> attr(,\"info\") #>    rowNr formNr itemNr   constraint #> 1      1      1     NA item_type>=2 #> 2      2      2     NA item_type>=2 #> 3      3      1     NA item_type>=2 #> 4      4      2     NA item_type>=2 #> 5      5      1     NA item_type>=2 #> 6      6      2     NA item_type>=2 #> 7      7      1     NA item_type<=4 #> 8      8      2     NA item_type<=4 #> 9      9      1     NA item_type<=4 #> 10    10      2     NA item_type<=4 #> 11    11      1     NA item_type<=4 #> 12    12      2     NA item_type<=4 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\" #> [11] \"it11\" \"it12\" \"it13\" \"it14\" \"it15\" \"it16\" \"it17\" \"it18\" \"it19\" \"it20\" #> [21] \"it21\" \"it22\" \"it23\" \"it24\" \"it25\" \"it26\" \"it27\" \"it28\" \"it29\" \"it30\"  ## or alternatively itemCategoryDeviationConstraint(2, item_type, targetValues = rep(3, 3), allowedDeviation = rep(4, 3)) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Error in itemValuesConstraint(nForms, 1 * (itemCategories == levels[levelNr]),     operator, targetValues[levelNr], whichForms, info_text[levelNr],     itemIDs): The 'targetValue' should be smaller than the sum of the 'itemValues'."},{"path":"https://beckerbenj.github.io/eatATA/reference/itemExclusionConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","title":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","text":"Create constraints prohibit item pairs occur test forms (exclusions) force item pairs test forms (inclusions).","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemExclusionConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","text":"","code":"itemExclusionConstraint(   nForms,   itemTuples,   itemIDs,   whichForms = seq_len(nForms),   info_text = NULL )  itemInclusionConstraint(   nForms,   itemTuples,   itemIDs,   whichForms = seq_len(nForms),   info_text = NULL )"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemExclusionConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","text":"nForms Number forms created. itemTuples data.frame two columns, containing tuples item IDs test forms inclusively exclusively. itemIDs Character vector item IDs correct ordering. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemExclusionConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemExclusionConstraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","text":"Item tuples can, example, created function itemTuples.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemExclusionConstraint.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","text":"itemExclusionConstraint(): item pair exclusion constraints itemInclusionConstraint(): item pair inclusion constraints","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemExclusionConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create item inclusion or exclusion constraints. — itemExclusionConstraint","text":"","code":"## Simple Exclusion Example # item-IDs IDs <- c(\"item1\", \"item2\", \"item3\", \"item4\")  # exclusion tuples: Item 1 can not be in the test form as item 2 and 3 exTuples <- data.frame(v1 = c(\"item1\", \"item1\"), v2 = c(\"item2\", \"item3\"),                        stringsAsFactors = FALSE) # inclusion tuples: Items 2 and 3 have to be in the same test form inTuples <- data.frame(v1 = c(\"item2\"), v2 = c(\"item3\"),                        stringsAsFactors = FALSE)  # create constraints itemExclusionConstraint(nForms = 2, itemTuples = exTuples, itemIDs = IDs) #> $A_binary #> 4 x 8 sparse Matrix of class \"dgCMatrix\" #>                      #> [1,] 1 1 0 0 . . . . #> [2,] . . . . 1 1 0 0 #> [3,] 1 0 1 0 . . . . #> [4,] . . . . 1 0 1 0 #>  #> $A_real #> NULL #>  #> $operators #> [1] \"<=\" \"<=\" \"<=\" \"<=\" #>  #> $d #> [1] 1 1 1 1 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 4 #> attr(,\"info\") #>   rowNr formNr itemNr           constraint #> 1     1      1     NA item1_excludes_item2 #> 2     2      2     NA item1_excludes_item2 #> 3     3      1     NA item1_excludes_item3 #> 4     4      2     NA item1_excludes_item3 #> attr(,\"itemIDs\") #> [1] \"item1\" \"item2\" \"item3\" \"item4\" itemInclusionConstraint(nForms = 2, itemTuples = inTuples, itemIDs = IDs) #> $A_binary #> 2 x 8 sparse Matrix of class \"dgCMatrix\" #>                        #> [1,] 0 1 -1 0 . .  . . #> [2,] . .  . . 0 1 -1 0 #>  #> $A_real #> NULL #>  #> $operators #> [1] \"=\" \"=\" #>  #> $d #> [1] 0 0 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 4 #> attr(,\"info\") #>   rowNr formNr itemNr           constraint #> 1     1      1     NA item2_includes_item3 #> 2     2      2     NA item2_includes_item3 #> attr(,\"itemIDs\") #> [1] \"item1\" \"item2\" \"item3\" \"item4\"   ######## ## Full workflow for exclusions using itemTuples # Example data.frame items <- data.frame(ID = c(\"item1\", \"item2\", \"item3\", \"item4\"),                      infoCol = c(\"item2, item3\", NA, NA, NA))  # Create tuples exTuples2 <- itemTuples(items = items, idCol = \"ID\", infoCol = \"infoCol\",                     sepPattern = \", \")  ## Create constraints itemExclusionConstraint(nForms = 2, itemTuples = exTuples2, itemIDs = IDs) #> $A_binary #> 4 x 8 sparse Matrix of class \"dgCMatrix\" #>                      #> [1,] 1 1 0 0 . . . . #> [2,] . . . . 1 1 0 0 #> [3,] 1 0 1 0 . . . . #> [4,] . . . . 1 0 1 0 #>  #> $A_real #> NULL #>  #> $operators #> [1] \"<=\" \"<=\" \"<=\" \"<=\" #>  #> $d #> [1] 1 1 1 1 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 4 #> attr(,\"info\") #>   rowNr formNr itemNr           constraint #> 1     1      1     NA item1_excludes_item2 #> 2     2      2     NA item1_excludes_item2 #> 3     3      1     NA item1_excludes_item3 #> 4     4      2     NA item1_excludes_item3 #> attr(,\"itemIDs\") #> [1] \"item1\" \"item2\" \"item3\" \"item4\""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemTuples.html","id":null,"dir":"Reference","previous_headings":"","what":"Create item tuples. — itemTuples","title":"Create item tuples. — itemTuples","text":"item inclusions exclusions stored character vector, itemTuples separates vector creates item pairs ('tuples').","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemTuples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create item tuples. — itemTuples","text":"","code":"itemTuples(items, idCol = \"ID\", infoCol, sepPattern = \", \")"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemTuples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create item tuples. — itemTuples","text":"items data.frame information item pool. idCol character integer indicating item ID column items. infoCol character integer indicating column items contains information tuples. sepPattern String used separating item IDs infoCol column.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemTuples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create item tuples. — itemTuples","text":"data.frame two columns.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemTuples.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create item tuples. — itemTuples","text":"Tuples can used itemExclusionConstraint set exclusion constraints itemInclusionConstraint set inclusion constraints. Note separator pattern used consistently throughout column (e.g. \", \").","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemTuples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create item tuples. — itemTuples","text":"","code":"# Example data.frame items <- data.frame(ID = c(\"item1\", \"item2\", \"item3\", \"item4\"),                      exclusions = c(\"item2, item3\", NA, NA, NA))  # Create tuples itemTuples(items = items, idCol = \"ID\", infoCol = 2,                     sepPattern = \", \") #>      [,1]    [,2]    #> [1,] \"item1\" \"item2\" #> [2,] \"item1\" \"item3\""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemUsageConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create item usage constraints. — itemUsageConstraint","title":"Create item usage constraints. — itemUsageConstraint","text":"Creates constraints related item usage. , number times item selected constrained either () smaller equal (operator = \"<=\"), (b) equal (operator = \"=\"), (c) greater equal (operator = \">=\") chosen value.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemUsageConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create item usage constraints. — itemUsageConstraint","text":"","code":"itemUsageConstraint(   nForms,   nItems = NULL,   formValues = rep(1, nForms),   operator = c(\"<=\", \"=\", \">=\"),   targetValue = 1,   whichItems = NULL,   info_text = NULL,   itemIDs = NULL )"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemUsageConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create item usage constraints. — itemUsageConstraint","text":"nForms Number forms created. nItems Number items item pool [optional create itemIDs automatically]. formValues vector values weights form. Defaults 1 form. operator character indicating operator used constraints, three possible values: \"<=\", \"=\", \">=\". See details information. targetValue value used constraints whichItems vector indicating items constrained. Defaults items. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemUsageConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create item usage constraints. — itemUsageConstraint","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemUsageConstraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create item usage constraints. — itemUsageConstraint","text":"operator = \"<=\" value = 1 (default), item can selected maximally , corresponds assuring item overlap forms. operator = \"=\" value = 1, item used exactly , corresponds item-overlap complete item pool depletion. certain items required resulting test form(s), example anchor items, whichItems can used constrain usage items exactly 1. whichItems can either numeric vector item numbers character vector item identifiers corresponding itemIDs.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemUsageConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create item usage constraints. — itemUsageConstraint","text":"","code":"## create no-item overlap constraints with item pool depletion ##  for 2 test forms with an item pool of 20 items itemUsageConstraint(2, operator = \"=\", targetValue = 1,                     itemIDs = 1:20) #> $A_binary #> 20 x 40 sparse Matrix of class \"dgCMatrix\" #>                                                                                 #>  [1,] 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . #>  [2,] . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . #>  [3,] . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . #>  [4,] . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . #>  [5,] . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . #>  [6,] . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . #>  [7,] . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . #>  [8,] . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . #>  [9,] . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . #> [10,] . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . . #> [11,] . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . . #> [12,] . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . . #> [13,] . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . . #> [14,] . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . . #> [15,] . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . . #> [16,] . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 . #> [17,] . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . 1 #> [18,] . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . . #> [19,] . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . . #> [20,] . . . . . . . . . . . . . . . . . . . 1 . . . . . . . . . . . . . . . . . #>             #>  [1,] . . . #>  [2,] . . . #>  [3,] . . . #>  [4,] . . . #>  [5,] . . . #>  [6,] . . . #>  [7,] . . . #>  [8,] . . . #>  [9,] . . . #> [10,] . . . #> [11,] . . . #> [12,] . . . #> [13,] . . . #> [14,] . . . #> [15,] . . . #> [16,] . . . #> [17,] . . . #> [18,] 1 . . #> [19,] . 1 . #> [20,] . . 1 #>  #> $A_real #> NULL #>  #> $operators #>  [1] \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" \"=\" #> [20] \"=\" #>  #> $d #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 20 #> attr(,\"info\") #>    rowNr formNr itemNr       constraint #> 1      1     NA      1 rep(1, nForms)=1 #> 2      2     NA      2 rep(1, nForms)=1 #> 3      3     NA      3 rep(1, nForms)=1 #> 4      4     NA      4 rep(1, nForms)=1 #> 5      5     NA      5 rep(1, nForms)=1 #> 6      6     NA      6 rep(1, nForms)=1 #> 7      7     NA      7 rep(1, nForms)=1 #> 8      8     NA      8 rep(1, nForms)=1 #> 9      9     NA      9 rep(1, nForms)=1 #> 10    10     NA     10 rep(1, nForms)=1 #> 11    11     NA     11 rep(1, nForms)=1 #> 12    12     NA     12 rep(1, nForms)=1 #> 13    13     NA     13 rep(1, nForms)=1 #> 14    14     NA     14 rep(1, nForms)=1 #> 15    15     NA     15 rep(1, nForms)=1 #> 16    16     NA     16 rep(1, nForms)=1 #> 17    17     NA     17 rep(1, nForms)=1 #> 18    18     NA     18 rep(1, nForms)=1 #> 19    19     NA     19 rep(1, nForms)=1 #> 20    20     NA     20 rep(1, nForms)=1 #> attr(,\"itemIDs\") #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20  ## force certain items to be in the test, others not usage1 <- itemUsageConstraint(2, operator = \"<=\", targetValue = 1,                     itemIDs = paste0(\"item\", 1:20)) usage2 <- itemUsageConstraint(2, operator = \"=\", targetValue = 1,                     itemIDs = paste0(\"item\", 1:20),                     whichItems = c(\"item5\", \"item8\", \"item10\"))"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Constrain the sum of item values per form. — itemValuesConstraint","title":"Constrain the sum of item values per form. — itemValuesConstraint","text":"Create constraints related item parameter/value. , created constraints assure sum item values (itemValues) per test form either () smaller equal (operator = \"<=\"), (b) equal (operator = \"=\"), (c) greater equal (operator = \">=\") chosen targetValue.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constrain the sum of item values per form. — itemValuesConstraint","text":"","code":"itemValuesConstraint(   nForms,   itemValues,   operator = c(\"<=\", \"=\", \">=\"),   targetValue,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constrain the sum of item values per form. — itemValuesConstraint","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. operator character indicating operator used constraints, three possible values: \"<=\", \"=\", \">=\". See details information. targetValue target test form value. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constrain the sum of item values per form. — itemValuesConstraint","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesConstraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constrain the sum of item values per form. — itemValuesConstraint","text":"operator \"<=\", constraint can mathematically formulated : \\[\\sum_{=1}^{} v_i \\times x_{} \\leq t , \\; \\; \\; \\code{} \\:  f \\G,\\] \\(\\) refers number items item pool, \\(v_i\\) itemValue item \\(\\) \\(t\\) targetValue. , \\(G\\) corresponds whichForms, inequality constraint repeated every test form \\(f\\) \\(G\\). addition, let \\(\\boldsymbol{x}\\) vector binary decision variables length \\(\\times F\\), \\(F\\) nForms. binary decision variables \\(x_{}\\) defined :","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constrain the sum of item values per form. — itemValuesConstraint","text":"","code":"## constraints to make sure that the sum of the item values (1:10) is between ## 4 and 6 combineConstraints(   itemValuesConstraint(2, 1:10, operator = \">=\", targetValue = 4),   itemValuesConstraint(2, 1:10, operator = \"<=\", targetValue = 6) ) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 4 x 20 sparse Matrix of class \"dgCMatrix\" #>                                                #> [1,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [2,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #> [3,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [4,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #>  #> $A_real #> NULL #>  #> $operators #> [1] \">=\" \">=\" \"<=\" \"<=\" #>  #> $d #> [1] 4 4 6 6 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"info\") #>   rowNr formNr itemNr constraint #> 1     1      1     NA    1:10>=4 #> 2     2      2     NA    1:10>=4 #> 3     3      1     NA    1:10<=6 #> 4     4      2     NA    1:10<=6 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesRangeConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","title":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","text":"itemValuesRangeConstraint, itemValuesMinConstraint, itemValuesMaxConstraint create constraints related item parameter/value. , created constraints assure sum itemValues smaller equal max, greater equal min, range.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesRangeConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","text":"","code":"itemValuesRangeConstraint(   nForms,   itemValues,   range,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )  itemValuesMinConstraint(   nForms,   itemValues,   min,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )  itemValuesMaxConstraint(   nForms,   itemValues,   max,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )  itemValuesDeviationConstraint(   nForms,   itemValues,   targetValue,   allowedDeviation,   relative = FALSE,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesRangeConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. range vector two values, minimal maximum sum itemValues per test form, respectively whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL. min minimal sum itemValues per test form max minimal sum itemValues per test form targetValue target test form value. allowedDeviation maximum allowed deviation targetValue relative logical expressing whether allowedDeviation interpreted proportion targetValue","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesRangeConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesRangeConstraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","text":"itemValuesDeviationConstraint also constrains minimal maximal value sum itemValues, based chosen maximal allowed deviation (.e., allowedDeviation) targetValue.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesRangeConstraint.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","text":"itemValuesMinConstraint(): constrain minimum value itemValuesMaxConstraint(): constrain maximum value itemValuesDeviationConstraint(): constrain distance form targetValue","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemValuesRangeConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create single value constraints with minimum and maximum. — itemValuesRangeConstraint","text":"","code":"## constraints to make sure that the sum of the item values (1:10) is between ## 4 and 6 itemValuesRangeConstraint(2, 1:10, range(min = 4, max = 6)) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 4 x 20 sparse Matrix of class \"dgCMatrix\" #>                                                #> [1,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [2,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #> [3,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [4,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #>  #> $A_real #> NULL #>  #> $operators #> [1] \">=\" \">=\" \"<=\" \"<=\" #>  #> $d #> [1] 4 4 6 6 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"info\") #>   rowNr formNr itemNr constraint #> 1     1      1     NA    1:10>=4 #> 2     2      2     NA    1:10>=4 #> 3     3      1     NA    1:10<=6 #> 4     4      2     NA    1:10<=6 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\"  ## or alternatively itemValuesDeviationConstraint(2, 1:10, targetValue = 5, allowedDeviation = 1) #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> Warning: Argument 'itemIDs' is missing. 'itemIDs' will be generated automatically. #> $A_binary #> 4 x 20 sparse Matrix of class \"dgCMatrix\" #>                                                #> [1,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [2,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #> [3,] 1 2 3 4 5 6 7 8 9 10 . . . . . . . . .  . #> [4,] . . . . . . . . .  . 1 2 3 4 5 6 7 8 9 10 #>  #> $A_real #> NULL #>  #> $operators #> [1] \">=\" \">=\" \"<=\" \"<=\" #>  #> $d #> [1] 4 4 6 6 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"info\") #>   rowNr formNr itemNr constraint #> 1     1      1     NA    1:10>=4 #> 2     2      2     NA    1:10>=4 #> 3     3      1     NA    1:10<=6 #> 4     4      2     NA    1:10<=6 #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemsPerFormConstraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Create number of items per test form constraints. — itemsPerFormConstraint","title":"Create number of items per test form constraints. — itemsPerFormConstraint","text":"Creates constraints related number items test form.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemsPerFormConstraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create number of items per test form constraints. — itemsPerFormConstraint","text":"","code":"itemsPerFormConstraint(   nForms,   nItems = NULL,   operator = c(\"<=\", \"=\", \">=\"),   targetValue,   whichForms = seq_len(nForms),   itemIDs = NULL )"},{"path":"https://beckerbenj.github.io/eatATA/reference/itemsPerFormConstraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create number of items per test form constraints. — itemsPerFormConstraint","text":"nForms Number forms created. nItems Number items item pool [optional create itemIDs automatically]. operator character indicating operator used constraints, three possible values: \"<=\", \"=\", \">=\". See details information. targetValue target value used constraints. , number items per form. whichForms integer vector indicating test forms constrained. Defaults test forms. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemsPerFormConstraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create number of items per test form constraints. — itemsPerFormConstraint","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemsPerFormConstraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create number of items per test form constraints. — itemsPerFormConstraint","text":"number items per test form constrained either () smaller equal (operator = \"<=\"), (b) equal (operator = \"=\"), (c) greater equal (operator = \">=\") chosen value.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/itemsPerFormConstraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create number of items per test form constraints. — itemsPerFormConstraint","text":"","code":"## Constrain the test forms to have exactly five items itemsPerFormConstraint(3, operator = \"=\", targetValue = 5,                        itemIDs = 1:20) #> $A_binary #> 3 x 60 sparse Matrix of class \"dgCMatrix\" #>                                                                                #> [1,] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #> [2,] . . . . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #> [3,] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #>                                                    #> [1,] . . . . . . . . . . . . . . . . . . . . . . . #> [2,] 1 1 1 . . . . . . . . . . . . . . . . . . . . #> [3,] . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #>  #> $A_real #> NULL #>  #> $operators #> [1] \"=\" \"=\" \"=\" #>  #> $d #> [1] 5 5 5 #>  #> $c_binary #> NULL #>  #> $c_real #> NULL #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 3 #> attr(,\"nItems\") #> [1] 20 #> attr(,\"info\") #>   rowNr formNr itemNr     constraint #> 1     1      1     NA itemsPerForm=5 #> 2     2      2     NA itemsPerForm=5 #> 3     3      3     NA itemsPerForm=5 #> attr(,\"itemIDs\") #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20"},{"path":"https://beckerbenj.github.io/eatATA/reference/items_diao.html","id":null,"dir":"Reference","previous_headings":"","what":"Small simulated item pool example. — items_diao","title":"Small simulated item pool example. — items_diao","text":"data.frame containing 165 items calibrated using 3PL model. item pool analogous one item pools used Diao & van der Linden (2011).","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_diao.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Small simulated item pool example. — items_diao","text":"","code":"items_diao"},{"path":"https://beckerbenj.github.io/eatATA/reference/items_diao.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Small simulated item pool example. — items_diao","text":"data.frame . item Item identifier. Discrimination parameter. b Difficulty parameter. c Pseudo-guessing parameter. category Content category.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_diao.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Small simulated item pool example. — items_diao","text":"Diao, Q. & van der Linden, W.J. (2011). Automated test assembly using lp_solve version 5.5 R. Applied Psychological Measurement, 35 (5), 398-409.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_lsa.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated item pool example. — items_lsa","title":"Simulated item pool example. — items_lsa","text":"data.frame containing 209 calibrated items different categorical metric properties, comparable item pool large-scale assessment.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_lsa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated item pool example. — items_lsa","text":"","code":"items_lsa"},{"path":"https://beckerbenj.github.io/eatATA/reference/items_lsa.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated item pool example. — items_lsa","text":"data.frame . testlet Testlet identifier (items testlet share common stimulus. item Item identifier. level Competence level. format Item format. frequency Solution frequency. infit Item infit. time Average response time seconds. anchor item anchor item?","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_mini.html","id":null,"dir":"Reference","previous_headings":"","what":"Small simulated item pool example. — items_mini","title":"Small simulated item pool example. — items_mini","text":"data.frame containing 30 items different categorical metric properties.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_mini.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Small simulated item pool example. — items_mini","text":"","code":"items_mini"},{"path":"https://beckerbenj.github.io/eatATA/reference/items_mini.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Small simulated item pool example. — items_mini","text":"data.frame . item Item identifier. format Item format (e.g., multiple choice, open answer, order item). time Average response time seconds. difficulty IRT difficulty parameter.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_pilot.html","id":null,"dir":"Reference","previous_headings":"","what":"Small simulated item pool example. — items_pilot","title":"Small simulated item pool example. — items_pilot","text":"data.frame containing 100 yet calibrated items different categorical metric properties.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_pilot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Small simulated item pool example. — items_pilot","text":"","code":"items_pilot"},{"path":"https://beckerbenj.github.io/eatATA/reference/items_pilot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Small simulated item pool example. — items_pilot","text":"data.frame . item Item identifier. diffCategory Item difficulty (five categories). format Item format (multiple choice, constructed multiple choice, open answer). domain Item domain (listening, reading, writing). time Average response times seconds. exclusions Items can test form.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_vera.html","id":null,"dir":"Reference","previous_headings":"","what":"Small artificial item pool example. — items_vera","title":"Small artificial item pool example. — items_vera","text":"data.frame containing 80 items different categorical metric properties.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/items_vera.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Small artificial item pool example. — items_vera","text":"","code":"items_vera"},{"path":"https://beckerbenj.github.io/eatATA/reference/items_vera.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Small artificial item pool example. — items_vera","text":"data.frame . item Item identifier. exclusions Items can test form. time Average response times minutes. 2.5 equals 2 minutes 30 seconds, example. subitems Number sub items. MC, CMC, short_answer, open Answer formats. diff_1, diff_2, diff_3, diff_4, diff5 Difficulty categories.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/matrixExclusionTuples.html","id":null,"dir":"Reference","previous_headings":"","what":"Create item exclusion tuples from matrix. — matrixExclusionTuples","title":"Create item exclusion tuples from matrix. — matrixExclusionTuples","text":"item exclusions stored matrix, matrixExclusionTuples transforms format item pairs ('tuples'). Information exclusions coded 1 (items exclusive) 0 (items exclusive).","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/matrixExclusionTuples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create item exclusion tuples from matrix. — matrixExclusionTuples","text":"","code":"matrixExclusionTuples(exclMatrix)"},{"path":"https://beckerbenj.github.io/eatATA/reference/matrixExclusionTuples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create item exclusion tuples from matrix. — matrixExclusionTuples","text":"exclMatrix data.frame matrix information item exclusiveness.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/matrixExclusionTuples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create item exclusion tuples from matrix. — matrixExclusionTuples","text":"data.frame two columns.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/matrixExclusionTuples.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create item exclusion tuples from matrix. — matrixExclusionTuples","text":"Exclusion tuples can used itemExclusionConstraint set exclusion constraints.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/matrixExclusionTuples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create item exclusion tuples from matrix. — matrixExclusionTuples","text":"","code":"# Example data.frame exclDF <- data.frame(c(0, 1, 0, 0),                      c(1, 0, 0, 1),                      c(0, 0, 0, 0),                      c(0, 1, 0, 0)) rownames(exclDF) <- colnames(exclDF) <- paste0(\"item_\", 1:4)  # Create tuples matrixExclusionTuples(exclDF) #>      [,1]     [,2]     #> [1,] \"item_1\" \"item_2\" #> [2,] \"item_2\" \"item_4\""},{"path":"https://beckerbenj.github.io/eatATA/reference/maxObjective.html","id":null,"dir":"Reference","previous_headings":"","what":"Max Constraint. — maxObjective","title":"Max Constraint. — maxObjective","text":"Create max-constraints related item parameter/value. , created constraints can used maximize sum item values (itemValues) test form. Note constraint can used one test form assembled.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/maxObjective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Max Constraint. — maxObjective","text":"","code":"maxObjective(   nForms,   itemValues,   weight = 1,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/maxObjective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Max Constraint. — maxObjective","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. weight weight real-valued variable(s). Useful multiple constraints combined. used implications well understood. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/maxObjective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Max Constraint. — maxObjective","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/maxObjective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Max Constraint. — maxObjective","text":"","code":"# constraint that maximizes the sum of the itemValues maxObjective(nForms = 1, itemValues = rep(-2:2, 2)) #> $A_binary #> 1 x 10 sparse Matrix of class \"dgCMatrix\" #>                              #> [1,] -2 -1 0 1 2 -2 -1 0 1 2 #>  #> $A_real #>      [,1] #> [1,]   -1 #>  #> $operators #> [1] \">=\" #>  #> $d #> [1] 0 #>  #> $c_binary #> NULL #>  #> $c_real #> [1] 1 #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 1 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"sense\") #> [1] \"max\" #> attr(,\"info\") #>   rowNr formNr itemNr constraint #> 1     1      1     NA        max #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/maximinObjective.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximin Constraint. — maximinObjective","title":"Maximin Constraint. — maximinObjective","text":"Create maximin-constraints related item parameter/value. , created constraints can used maximize minimal sum item values (itemValues), time setting upper limit overflow means maximally allowed deviation allowedDeviation.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/maximinObjective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximin Constraint. — maximinObjective","text":"","code":"maximinObjective(   nForms,   itemValues,   allowedDeviation,   weight = 1,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/maximinObjective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximin Constraint. — maximinObjective","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. allowedDeviation maximum allowed deviation sum target values. weight weight real-valued variable(s). Useful multiple constraints combined. used implications well understood. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/maximinObjective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximin Constraint. — maximinObjective","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/maximinObjective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximin Constraint. — maximinObjective","text":"","code":"# constraint that minimizes the maximum difference per test form value and a #   target value of 0 maximinObjective(nForms = 2, itemValues = rep(-2:2, 2),                  allowedDeviation = 1) #> $A_binary #> 4 x 20 sparse Matrix of class \"dgCMatrix\" #>                                                      #> [1,] -2 -1 0 1 2 -2 -1 0 1 2  .  . . . .  .  . . . . #> [2,]  .  . . . .  .  . . . . -2 -1 0 1 2 -2 -1 0 1 2 #> [3,] -2 -1 0 1 2 -2 -1 0 1 2  .  . . . .  .  . . . . #> [4,]  .  . . . .  .  . . . . -2 -1 0 1 2 -2 -1 0 1 2 #>  #> $A_real #>      [,1] #> [1,]   -1 #> [2,]   -1 #> [3,]   -1 #> [4,]   -1 #>  #> $operators #> [1] \">=\" \">=\" \"<=\" \"<=\" #>  #> $d #> [1] 0 0 1 1 #>  #> $c_binary #> NULL #>  #> $c_real #> [1] 1 #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"sense\") #> [1] \"max\" #> attr(,\"info\") #>   rowNr formNr itemNr         constraint #> 1     1      1     NA maximin_lowerBound #> 2     2      2     NA maximin_lowerBound #> 3     3      1     NA maximin_upperBound #> 4     4      2     NA maximin_upperBound #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/minObjective.html","id":null,"dir":"Reference","previous_headings":"","what":"Min Constraint. — minObjective","title":"Min Constraint. — minObjective","text":"Create min-constraints related item parameter/value. , created constraints can used minimize sum item values (itemValues) test form. Note constraint can used one test form assembled.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/minObjective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Min Constraint. — minObjective","text":"","code":"minObjective(   nForms,   itemValues,   weight = 1,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/minObjective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Min Constraint. — minObjective","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. weight weight real-valued variable(s). Useful multiple constraints combined. used implications well understood. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/minObjective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Min Constraint. — minObjective","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/minObjective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Min Constraint. — minObjective","text":"","code":"# constraint that maximizes the sum of the itemValues maxObjective(nForms = 1, itemValues = rep(-2:2, 2)) #> $A_binary #> 1 x 10 sparse Matrix of class \"dgCMatrix\" #>                              #> [1,] -2 -1 0 1 2 -2 -1 0 1 2 #>  #> $A_real #>      [,1] #> [1,]   -1 #>  #> $operators #> [1] \">=\" #>  #> $d #> [1] 0 #>  #> $c_binary #> NULL #>  #> $c_real #> [1] 1 #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 1 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"sense\") #> [1] \"max\" #> attr(,\"info\") #>   rowNr formNr itemNr constraint #> 1     1      1     NA        max #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/minimaxObjective.html","id":null,"dir":"Reference","previous_headings":"","what":"Minimax Constraint. — minimaxObjective","title":"Minimax Constraint. — minimaxObjective","text":"Create minimax-constraints related item parameter/value. , created constraints can used minimize maximum distance sum item values (itemValues) per test form chosen targetValue.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/minimaxObjective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Minimax Constraint. — minimaxObjective","text":"","code":"minimaxObjective(   nForms,   itemValues,   targetValue,   weight = 1,   whichForms = seq_len(nForms),   info_text = NULL,   itemIDs = names(itemValues) )"},{"path":"https://beckerbenj.github.io/eatATA/reference/minimaxObjective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Minimax Constraint. — minimaxObjective","text":"nForms Number forms created. itemValues Item parameter/values sum per test form constrained. targetValue target test form value. weight weight real-valued variable(s). Useful multiple constraints combined. used implications well understood. whichForms integer vector indicating test forms constrained. Defaults test forms. info_text character string length 1, used \"info\"-attribute resulting constraint-object. itemIDs character vector item IDs correct ordering, NULL.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/minimaxObjective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Minimax Constraint. — minimaxObjective","text":"object class \"constraint\".","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/minimaxObjective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Minimax Constraint. — minimaxObjective","text":"","code":"# constraint that minimizes the maximum difference per test form value and a #   target value of 0 minimaxObjective(nForms = 2,                  itemValues = rep(-2:2, 2),                  targetValue = 0) #> $A_binary #> 4 x 20 sparse Matrix of class \"dgCMatrix\" #>                                                      #> [1,] -2 -1 0 1 2 -2 -1 0 1 2  .  . . . .  .  . . . . #> [2,]  .  . . . .  .  . . . . -2 -1 0 1 2 -2 -1 0 1 2 #> [3,] -2 -1 0 1 2 -2 -1 0 1 2  .  . . . .  .  . . . . #> [4,]  .  . . . .  .  . . . . -2 -1 0 1 2 -2 -1 0 1 2 #>  #> $A_real #>      [,1] #> [1,]   -1 #> [2,]   -1 #> [3,]    1 #> [4,]    1 #>  #> $operators #> [1] \"<=\" \"<=\" \">=\" \">=\" #>  #> $d #> [1] 0 0 0 0 #>  #> $c_binary #> NULL #>  #> $c_real #> [1] 1 #>  #> attr(,\"class\") #> [1] \"constraint\" #> attr(,\"nForms\") #> [1] 2 #> attr(,\"nItems\") #> [1] 10 #> attr(,\"sense\") #> [1] \"min\" #> attr(,\"info\") #>   rowNr formNr itemNr         constraint #> 1     1      1     NA minimax_lowerBound #> 2     2      2     NA minimax_lowerBound #> 3     3      1     NA minimax_upperBound #> 4     4      2     NA minimax_upperBound #> attr(,\"itemIDs\") #>  [1] \"it01\" \"it02\" \"it03\" \"it04\" \"it05\" \"it06\" \"it07\" \"it08\" \"it09\" \"it10\""},{"path":"https://beckerbenj.github.io/eatATA/reference/stemInclusionTuples.html","id":null,"dir":"Reference","previous_headings":"","what":"Create item inclusion tuples from item stem. — stemInclusionTuples","title":"Create item inclusion tuples from item stem. — stemInclusionTuples","text":"item-stimulus hierarchies stored single stimulus column, stemInclusionTuples transforms format item pairs ('tuples').","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/stemInclusionTuples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create item inclusion tuples from item stem. — stemInclusionTuples","text":"","code":"stemInclusionTuples(items, idCol = \"ID\", stemCol)"},{"path":"https://beckerbenj.github.io/eatATA/reference/stemInclusionTuples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create item inclusion tuples from item stem. — stemInclusionTuples","text":"items data.frame information item pool. idCol character integer indicating item ID column items. stemCol column items containing item stems stimulus names, shared among items test form.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/stemInclusionTuples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create item inclusion tuples from item stem. — stemInclusionTuples","text":"data.frame two columns.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/stemInclusionTuples.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create item inclusion tuples from item stem. — stemInclusionTuples","text":"Inclusion tuples can used itemInclusionConstraint set inclusion constraints.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/stemInclusionTuples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create item inclusion tuples from item stem. — stemInclusionTuples","text":"","code":"# Example data.frame inclDF <- data.frame(ID = paste0(\"item_\", 1:6),           stem = c(rep(\"stim_1\", 3), \"stim_3\", \"stim_4\", \"stim_3\"),           stringsAsFactors = FALSE)  # Create tuples stemInclusionTuples(inclDF, idCol = \"ID\", stemCol = \"stem\") #>      [,1]     [,2]     #> [1,] \"item_1\" \"item_2\" #> [2,] \"item_1\" \"item_3\" #> [3,] \"item_2\" \"item_3\" #> [4,] \"item_4\" \"item_6\""},{"path":"https://beckerbenj.github.io/eatATA/reference/useSolver.html","id":null,"dir":"Reference","previous_headings":"","what":"Use a solver for a list of constraints. — useSolver","title":"Use a solver for a list of constraints. — useSolver","text":"Use mathematical programming solver solve list constrains.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/useSolver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use a solver for a list of constraints. — useSolver","text":"","code":"useSolver(   allConstraints,   solver = c(\"GLPK\", \"lpSolve\", \"Gurobi\", \"Symphony\"),   timeLimit = Inf,   formNames = NULL,   ... )"},{"path":"https://beckerbenj.github.io/eatATA/reference/useSolver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use a solver for a list of constraints. — useSolver","text":"allConstraints List constraints. solver character string indicating solver use. timeLimit maximal runtime seconds. formNames character vector names give forms. ... Additional arguments solver.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/useSolver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use a solver for a list of constraints. — useSolver","text":"list following elements: solution_found solution found? solution Numeric vector containing found solution. solution_status solution optimal?","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/useSolver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use a solver for a list of constraints. — useSolver","text":"Wrapper around functions different solvers (gurobi::gurobi(), lpSolve::lp(), ... list constraints set via eatATA. Rglpk used per default. Additional arguments can passed ... vary solver solver (see respective help pages, lp Rglpk_solve_LP); example time limits can set lpSolve.","code":""},{"path":"https://beckerbenj.github.io/eatATA/reference/useSolver.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use a solver for a list of constraints. — useSolver","text":"","code":"nForms <- 2 nItems <- 4  # create constraits target <- minimaxObjective(nForms = nForms, c(1, 0.5, 1.5, 2),                        targetValue = 2, itemIDs = 1:nItems) noItemOverlap <- itemUsageConstraint(nForms, operator = \"=\", itemIDs = 1:nItems) testLength <- itemsPerFormConstraint(nForms = nForms,                            operator = \"<=\", targetValue = 2, itemIDs = 1:nItems)  # use a solver result <- useSolver(list(target, noItemOverlap, testLength),   itemIDs = paste0(\"Item_\", 1:4),   solver = \"GLPK\") #> GLPK Simplex Optimizer 5.0 #> 10 rows, 9 columns, 36 non-zeros #>       0: obj =   0.000000000e+00 inf =   8.000e+00 (6) #>       6: obj =   5.000000000e-01 inf =   0.000e+00 (0) #> *     9: obj =   5.000000000e-01 inf =   0.000e+00 (0) #> OPTIMAL LP SOLUTION FOUND #> GLPK Integer Optimizer 5.0 #> 10 rows, 9 columns, 36 non-zeros #> 8 integer variables, all of which are binary #> Integer optimization begins... #> Long-step dual simplex will be used #> +     9: mip =     not found yet >=              -inf        (1; 0) #> +     9: >>>>>   5.000000000e-01 >=   5.000000000e-01   0.0% (1; 0) #> +     9: mip =   5.000000000e-01 >=     tree is empty   0.0% (0; 1) #> INTEGER OPTIMAL SOLUTION FOUND #> Optimal solution found."},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-112","dir":"Changelog","previous_headings":"","what":"eatATA 1.1.2","title":"eatATA 1.1.2","text":"CRAN release: 2023-12-12 internal testing fix (non-deterministic optimization problem deterministic tests)","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-111","dir":"Changelog","previous_headings":"","what":"eatATA 1.1.1","title":"eatATA 1.1.1","text":"CRAN release: 2022-11-28 internal testing fix","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-110","dir":"Changelog","previous_headings":"","what":"eatATA 1.1.0","title":"eatATA 1.1.0","text":"CRAN release: 2022-09-26 getMean2PLN() getMean2PLN() calculating mean two- three-parameter log-normal response time distributions, based set parameters. getMar2PLN() getVar2PLN() calculating variance two- three-parameter log-normal response time distributions, based set parameters bug fix inspectSolution() (works tibbles now) bug fix itemValuesConstraint() (works negative itemValues now) bug fix itemTuples() (#1)","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-100","dir":"Changelog","previous_headings":"","what":"eatATA 1.0.0","title":"eatATA 1.0.0","text":"CRAN release: 2021-07-06 updated overview vignette added mathematical formulations implementation help page itemValuesConstraint() added acrossFormsConstraint() constraints across test forms rigorous input checks constraint functions","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-0112","dir":"Changelog","previous_headings":"","what":"eatATA 0.11.2","title":"eatATA 0.11.2","text":"CRAN release: 2021-05-02 fix occasional system dependent test failure","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-0111","dir":"Changelog","previous_headings":"","what":"eatATA 0.11.1","title":"eatATA 0.11.1","text":"CRAN release: 2021-04-16 fix non ascii character help file","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-0110","dir":"Changelog","previous_headings":"","what":"eatATA 0.11.0","title":"eatATA 0.11.0","text":"constraint functions re-named consistently (now ending Constraint) objective function functions re-named consistently (now ending Objective) itemUsageConstraint() argument whichItem now takes character vector (item identifiers) input itemInclusionConstraint() added force items test forms stemInclusionTuples() added create inclusion tuples column shared stimulus itemExclusionTuples() renamed itemTuples(), can also used itemInclusionConstraint() argument names itemTuples() itemExclusionConstraint() slightly modified added simulated item pools examples renamed item pools consistently (items_mini, items_diao, items_pilot, items_vera, items_lsa)","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-0100","dir":"Changelog","previous_headings":"","what":"eatATA 0.10.0","title":"eatATA 0.10.0","text":"CRAN release: 2021-02-10 argument nItems either completely removed constraint functions exchangeable itemIDs itemTargetConstraint() substituted minimaxConstraint(), maximinConstraint(), maxConstraint(), minConstraint(), cappedMaximinConstraint() allow different types optimization goals Symphony added available solver (via Rsymphony) inspectSolution() now allows character variables input sums calculated autoItemValuesMinMax() now works different test length via testLength argument","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"documentation-0-10-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"eatATA 0.10.0","text":"reworked use case vignette added minimal example vignette added vignette package overview","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"internal-changes-0-10-0","dir":"Changelog","previous_headings":"","what":"Internal Changes","title":"eatATA 0.10.0","text":"input checks (feasible solution?) analyzeBlockExclusion() analyzeComplexBlockExclusion() uniqueness argument itemID checked introduction constraint-class specific methods constructor functions","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-091","dir":"Changelog","previous_headings":"","what":"eatATA 0.9.1","title":"eatATA 0.9.1","text":"CRAN release: 2020-12-07 GLPK lpSolve solvers now supported useSolver() function implemented, calls solver APIs directly inspectSolution() appendSolution() functions, use useSovler() output prepareConstraints() processGurobiOutput() retired calculateIIF() calculates item information function calculateExpectedRT() calculates expected response times","code":""},{"path":"https://beckerbenj.github.io/eatATA/news/index.html","id":"eatata-070","dir":"Changelog","previous_headings":"","what":"eatATA 0.7.0","title":"eatATA 0.7.0","text":"CRAN release: 2020-09-15 Initial CRAN release.","code":""}]
